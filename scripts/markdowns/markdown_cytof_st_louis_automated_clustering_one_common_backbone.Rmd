---
title: "CyTOF_St_Louis_automatic_metaclustering, one common backbone"
author: "Helena"
date: "16/04/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r imports, echo=FALSE, results='hide',  warning = FALSE}
suppressPackageStartupMessages({
  library("openxlsx")
  library("FlowSOM")
  library("tidyverse")
  library("magrittr")
  library("flowCore")
  library("flowWorkspace")
  library("ggraph")
  library("igraph")
  library("scales")
  library("dendextend")
  library("cowplot")
  library("pheatmap")
  library(dplyr)
  library(BioGVHD)
  library(data.table)
  library(dendextend)
  library(ggplot2)
  library(nnet)
  library(pROC)
  library(VennDiagram)
})
library(BioGVHD)
options("scipen"=100)
```


# Analysis on the donors and recipients

## FlowSOM map:

```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/fsom_rd.RData")
PlotStars(UpdateNodeSize(fsom_rd$FlowSOM, maxNodeSize = 8, reset = TRUE),
          markers = names(prettyMarkerNames)[which(prettyMarkerNames%in% c("CD11a","CD16","CD127","CD3","CD4","CD45RA","CD8a","HLADR","CD19",
                                                                            "CD38","CD161","CCR7","CD27","CCR4","CCR5","CD5","CXCR3","Fas",
                                                                            "foxP3","CD24","CXCR5"))],
          view = "MST")
```


## Automatic metaclustering with 40 metaclusters

FlowSOM's clusters were grouped into 40 metaclusters, using FlowSOM's function:

```{r load_new_table, echo = FALSE}
load("/Users/helenatodorov/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/pctgs_meta_rd_automatic_clustering.RData")
load("/Users/helenatodorov/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/samp_rd.RData")
load("/Users/helenatodorov/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/fsom_meta_rd_automatic_clustering.RData")
PlotLabels(fsom_meta_rd$FlowSOM, labels = colnames(pctgs_meta_rd), fontSize = .8)
```

# Distribution of patients' cells in the metaclusters

We can then have a closer look at the metaclusters in which the distribution of the patients from the different groups is significantly different:

```{r, echo = FALSE}
group_res <- samp_rd[rownames(pctgs_meta_rd),"GROUP"]

p_v_meta <- rep(NA, ncol(pctgs_meta_rd))
for (i in seq_len(ncol(pctgs_meta_rd))) {
  data_tmp <- data.frame(Var = pctgs_meta_rd[, i],Visit = group_res)
  #  library(ggplot2)
  #  ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  fit <- aov(Var ~ Visit, data = data_tmp)
  p_v_meta[i] <- summary(fit)[[1]][["Pr(>F)"]][1]
  if(p_v_meta[i] < 0.05){g<-ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  print(g + ggtitle(colnames(pctgs_meta_rd)[i]))}
}
```

We can also look at barplots of the patients' percentages in the metaclusters of interest:

```{r, echo = FALSE}
different_pops <- colnames(pctgs_meta_rd)[which(p_v_meta<0.05)]

mat2plot <- as.data.frame(pctgs_meta_rd) %>%
rownames_to_column("Id.Cryostem.R") %>%
inner_join(samp_rd, by = "Id.Cryostem.R") %>%
arrange(COUPLENUMBER)

color_vector <- c("#FF0000","#00FF00","#0000FF")[mat2plot$GROUP]
color_vector[seq(1,67, by = 2)] <- paste0(color_vector[seq(1,67, by = 2)],"30")

for(metacluster in different_pops){
barplot(mat2plot[,metacluster], col = color_vector,
main = metacluster)
}
plot.new()
legend("center",legend=c("Donors_non_tolerant", "Recipients_non_tolerant", "Donors_secondary_tolerant",
"Recipients_secondary_tolerant", "Donors_primary_tolerant", "Recipients_primary_tolerant"),
col=c("#FF000030", "#FF0000", "#0000FF30", "#0000FF", "#00FF0030", "#00FF00"),
pch=19, cex=1)
```

```{r}
samp_rd_rearranged <- samp_rd %>%
arrange(GROUP) %>%
column_to_rownames("Id.Cryostem.R")
tab_hm <- as.data.frame(pctgs_meta_rd)
tab_hm <- tab_hm[rownames(samp_rd_rearranged),]
samp_rd_rearranged[,9] <- as.factor(samp_rd_rearranged[,9])
pheatmap(tab_hm, annotation_row = samp_rd_rearranged[,c(1,9)],
cluster_rows = F)
```


# Run PCA

We then visualised the donors and recipients on a same PCA, which was built on the patient's cell
profiles as identified in the FlowSOM map above. We measured the distances between donors and recipients
from the same couple on the PCA.

```{r, echo = FALSE}
pca <- prcomp(pctgs_meta_rd)
plot(pca$x)

distances = c()
for (i in names(table(samp_rd$COUPLENUMBER))){
  group_status <- samp_rd$GROUP[which(samp_rd$COUPLENUMBER==i)]
  pt_coord <- pca$x[rownames(samp_rd)[which(samp_rd$COUPLENUMBER==i)],c(1:2)]
  if(group_status[1]=="non_tolerant"){
    lines(pt_coord,col="red")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  } else if(group_status[1]=="primary_tolerant"){
    lines(pt_coord,col="green")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  } else {
    lines(pt_coord,col="blue")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  }
  distances = c(distances, sqrt((pt_coord[2,1]-pt_coord[1,1])^2 + (pt_coord[2,2]-pt_coord[1,2])^2))
}

list_couples <- names(table(samp_rd$COUPLENUMBER))
names(distances) <- paste0("couple_",samp_rd$COUPLENUMBER[which(samp_rd$COUPLENUMBER %in% list_couples)][1:34])
dis_colors <- c("red","green","blue")[samp_rd$GROUP[which(samp_rd$COUPLENUMBER %in% list_couples)][1:34]]
order_dis <- order(distances)

plot(distances[order_dis], col = dis_colors[order_dis], pch=19,
     main = "Distance between donor and recipient from same couple",
     ylab = "Distance D/R", xaxt = "n", xlab = "")
axis(1, at=1:34, labels=FALSE)
text(x=1:34, y=par()$usr[3]-0.1*(par()$usr[4]-par()$usr[3]),
     labels=names(distances[order_dis]), srt=45, adj=1, xpd=TRUE, cex = .7)
legend("topleft", c("non_tolerant","primary_tolerant","secondary_tolerant"),
       col = c("red","green","blue"), pch = 19)
```

which variables drive the PCA's components?

```{r}
pca$rotation[,1:2][which((abs(pca$rotation[,1])>0.05)&(abs(pca$rotation[,2])>0.05)),1:2]

```

# Run random forest on D-R:

Trying to classifiy into the 3 groups : primary, secondary and non-tolerant:

```{r rf, echo = FALSE}
df_tmp <- merge(data.frame(pctgs_meta_rd), samp_rd, by="row.names") %>%
dplyr::select(c(make.names(colnames(pctgs_meta_rd)), "Id.Cryostem.R", "GROUP", "COUPLENUMBER")) %>%
arrange(COUPLENUMBER)

pctgs_meta_couple <- df_tmp %>%
group_by(COUPLENUMBER) %>%
summarise_if(is.numeric, ~.[1]-.[2]) %>%
mutate(group = unique(df_tmp[,c("GROUP", "COUPLENUMBER")])$GROUP) %>%
column_to_rownames("COUPLENUMBER")

rf_subst <- randomForest::randomForest(group~., pctgs_meta_couple)
rf_subst
```

Trying to classify between non tolerant and tolerant couples:

```{r rf_non-tol_tol}
rf <- rf_tol_non_tol(df_orig = pctgs_meta_couple, mtry = 3, ntree = 10000)
rf
```

The classification results are very bad, almost all patients are classified as "non_tolerant"

I still try to classify between tolerant patients only (primary versus secondary):

```{r}
rf_tol <- rf_tol1_tol2(df_orig = pctgs_meta_couple, mtry = 3, ntree = 10000)
rf_tol
```

But it seems like, based on the percentages in FlowSOM's metaclusters, we're not able to
make a distinction between primary and secondary tolerant patients.

# Distribution of positive cells for the functional markers in the metaclusters

We can also look at the percentage of cells expressing specific functional markers in FlowSOM's metaclusters,
based on the FlowJo workspaces of Laetitia:

```{r, echo = FALSE}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/ratios_funct_meta_rd_automatic_clustering.RData")
patient_names <- gsub("^[0-9]*_([^_]*)_.*", "\\1", names(result))
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/funct_mark_res_automatic_clustering.RData")
funct_big_table <- do.call(cbind, tables_res)
rownames(funct_big_table) <- patient_names
```

We can then extract the metaclusters in which the distribution of the cells positive for certain functional markers in patients from the different groups is significantly different:

```{r, echo = FALSE}
group_res <- samp_rd[rownames(funct_big_table),"GROUP"]

p_v_meta <- rep(NA, ncol(funct_big_table))
for (i in seq_len(ncol(funct_big_table))) {
  data_tmp <- data.frame(Var = funct_big_table[, i],Visit = group_res)
  #  library(ggplot2)
  #  ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  if(all(data_tmp$Var==0)){
    p_v_meta[i] <- 1
  } else {
    fit <- aov(Var ~ Visit, data = data_tmp)
    p_v_meta[i] <- summary(fit)[[1]][["Pr(>F)"]][1]
    if(p_v_meta[i] < 0.005){g<-ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
    print(g + ggtitle(colnames(funct_big_table)[i]))}
  }
}
```

We can also look at barplots of the patients' percentages in the metaclusters of interest:

```{r, echo = FALSE}
different_pops <- colnames(funct_big_table)[which(p_v_meta<0.005)]

mat2plot <- as.data.frame(funct_big_table) %>%
rownames_to_column("Id.Cryostem.R") %>%
inner_join(samp_rd, by = "Id.Cryostem.R") %>%
arrange(COUPLENUMBER)

color_vector <- c("#FF0000","#00FF00","#0000FF")[mat2plot$GROUP]
color_vector[seq(1,67, by = 2)] <- paste0(color_vector[seq(1,67, by = 2)],"30")

for(metacluster in different_pops){
barplot(mat2plot[,metacluster], col = color_vector,
main = metacluster)
}
plot.new()
legend("center",legend=c("Donors_non_tolerant", "Recipients_non_tolerant", "Donors_secondary_tolerant",
"Recipients_secondary_tolerant", "Donors_primary_tolerant", "Recipients_primary_tolerant"),
col=c("#FF000030", "#FF0000", "#0000FF30", "#0000FF", "#00FF0030", "#00FF00"),
pch=19, cex=1)
```

PCA on the functional markers only:

```{r, echo = FALSE}
pca_f <- prcomp(funct_big_table)
plot(pca_f$x)

distances = c()
for (i in names(table(samp_rd$COUPLENUMBER))){
  group_status <- samp_rd$GROUP[which(samp_rd$COUPLENUMBER==i)]
  pt_coord <- pca_f$x[rownames(samp_rd)[which(samp_rd$COUPLENUMBER==i)],c(1:2)]
  if(group_status[1]=="non_tolerant"){
    lines(pt_coord,col="red")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  } else if(group_status[1]=="primary_tolerant"){
    lines(pt_coord,col="green")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  } else {
    lines(pt_coord,col="blue")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  }
  distances = c(distances, sqrt((pt_coord[2,1]-pt_coord[1,1])^2 + (pt_coord[2,2]-pt_coord[1,2])^2))
}

list_couples <- names(table(samp_rd$COUPLENUMBER))
names(distances) <- paste0("couple_",samp_rd$COUPLENUMBER[which(samp_rd$COUPLENUMBER %in% list_couples)][1:34])
dis_colors <- c("red","green","blue")[samp_rd$GROUP[which(samp_rd$COUPLENUMBER %in% list_couples)][1:34]]
order_dis <- order(distances)

plot(distances[order_dis], col = dis_colors[order_dis], pch=19,
     main = "Distance between donor and recipient from same couple",
     ylab = "Distance D/R", xaxt = "n", xlab = "")
axis(1, at=1:34, labels=FALSE)
text(x=1:34, y=par()$usr[3]-0.1*(par()$usr[4]-par()$usr[3]),
     labels=names(distances[order_dis]), srt=45, adj=1, xpd=TRUE, cex = .7)
legend("topleft", c("non_tolerant","primary_tolerant","secondary_tolerant"),
       col = c("red","green","blue"), pch = 19)
```

```{r}
pca_f$rotation[which((abs(pca_f$rotation[,1])>0.1)&(abs(pca_f$rotation[,2])>0.1)),1:2]
pca_f$rotation[which((abs(pca_f$rotation[,1])>0.05)&(abs(pca_f$rotation[,2])>0.05)),1:2]
```

Random forest on the functional markers only:

```{r, echo = FALSE}
df_tmp_f <- merge(data.frame(funct_big_table), samp_rd, by="row.names") %>%
  dplyr::select(c(make.names(colnames(funct_big_table)), "Id.Cryostem.R", "GROUP", "COUPLENUMBER")) %>%
  arrange(COUPLENUMBER)

df_f_couple <- df_tmp_f %>%
  group_by(COUPLENUMBER) %>%
  summarise_if(is.numeric, ~.[1]-.[2]) %>%
  mutate(group = unique(df_tmp_f[,c("GROUP", "COUPLENUMBER")])$GROUP) %>%
  column_to_rownames("COUPLENUMBER")

rf_f <- randomForest::randomForest(group~., df_f_couple)
rf_f
```

Trying to classify between non tolerant and tolerant couples:

```{r d-r_rf_non-tol-tol}
set.seed(1)
rf2_f <- rf_tol_non_tol(df_orig = df_f_couple, mtry = 70, ntree = 10000)
rf2_f
```

```{r, echo = FALSE}
features_idx <- which(rf2_f$importance[,3]>=0.01)
round(rf2_f$importance[features_idx,], 2)
features_of_interest <-
  rownames(rf2_f$importance)[features_idx]

subst.mds <- cmdscale(1 - rf2_f$proximity, eig=TRUE)
op <- par(pty="s")
pairs(cbind(df_f_couple[,features_idx], subst.mds$points), cex=0.6, gap=0,
      col=c("red", "blue")[as.numeric(df_f_couple$group)],
      main="Predictors and MDS of Proximity Based on RandomForest")
```

Trying to classify between tolerant patients only (primary versus secondary):

```{r}
set.seed(1)
rf_f_tol <- rf_tol1_tol2(df_orig = df_f_couple, mtry = 50, ntree = 10000)
rf_f_tol
```

# Distribution of patients' cells in the metaclusters and of the cells positive for the functional markers

Taking together information about the percentages in the FlowSOM metaclusters and the percentage of positive cells for the functional markers in these metaclusters:

```{r, echo = FALSE}
mat_pheno_funct <- merge(as.data.frame(pctgs_meta_rd), as.data.frame(funct_big_table), by = "row.names") %>%
  column_to_rownames("Row.names")


pca_pf <- prcomp(as.matrix(mat_pheno_funct))
plot(pca_pf$x)

samp_rd <- samp_rd[rownames(mat_pheno_funct),]

distances = c()
for (i in names(table(samp_rd$COUPLENUMBER))){
  group_status <- samp_rd$GROUP[which(samp_rd$COUPLENUMBER==i)]
  pt_coord <- pca_pf$x[rownames(samp_rd)[which(samp_rd$COUPLENUMBER==i)],c(1:2)]
  if(group_status[1]=="non_tolerant"){
    lines(pt_coord,col="red")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  } else if(group_status[1]=="primary_tolerant"){
    lines(pt_coord,col="green")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  } else {
    lines(pt_coord,col="blue")
    points(pt_coord[1,1], pt_coord[1,2], pch = 19)
  }
  distances = c(distances, sqrt((pt_coord[2,1]-pt_coord[1,1])^2 + (pt_coord[2,2]-pt_coord[1,2])^2))
}

list_couples <- names(table(samp_rd$COUPLENUMBER))
names(distances) <- paste0("couple_", list_couples)
couple_group <- samp_rd[,c("COUPLENUMBER", "GROUP")] %>%
  arrange(COUPLENUMBER)
dis_colors <- c("red","green","blue")[unique(couple_group)$GROUP]
order_dis <- order(distances)

plot(distances[order_dis], col = dis_colors[order_dis], pch=19,
     main = "Distance between donor and recipient from same couple",
     ylab = "Distance D/R", xaxt = "n", xlab = "")
axis(1, at=1:34, labels=FALSE)
text(x=1:34, y=par()$usr[3]-0.1*(par()$usr[4]-par()$usr[3]),
     labels=names(distances[order_dis]), srt=45, adj=1, xpd=TRUE, cex = .7)
legend("topleft", c("non_tolerant","primary_tolerant","secondary_tolerant"),
       col = c("red","green","blue"), pch = 19)
```

```{r}
pca_pf$rotation[which((abs(pca_pf$rotation[,1])>0.1)&(abs(pca_pf$rotation[,2])>0.1)),1:2]
pca_pf$rotation[which((abs(pca_pf$rotation[,1])>0.05)&(abs(pca_pf$rotation[,2])>0.05)),1:2]
```

Run RF on phenotypic and functional markers :

```{r}
pheno_funct <- cbind(pctgs_meta_couple[,-ncol(pctgs_meta_couple)], df_f_couple)
rf_pheno_funct <- randomForest::randomForest(group~., pheno_funct,
                                             mtry = 50, ntree = 10000)
rf_pheno_funct
```

Trying to classify between non tolerant and tolerant couples:

```{r}
set.seed(1)
rf2_pf <- rf_tol_non_tol(df_orig = pheno_funct, mtry = 50, ntree = 10000)
rf2_pf
```

```{r, echo = FALSE}
features_idx <- which(rf2_pf$importance[,3]>=0.008)
round(rf2_pf$importance[features_idx,], 2)
features_of_interest <-
  rownames(rf2_pf$importance)[features_idx]

subst.mds <- cmdscale(1 - rf2_pf$proximity, eig=TRUE)
op <- par(pty="s")
pairs(cbind(pheno_funct[,features_idx], subst.mds$points), cex=0.6, gap=0,
      col=c("red", "blue")[as.numeric(pheno_funct$group)],
      main="Predictors and MDS of Proximity Based on RandomForest")
```

Trying to classify between primary and secondary tolerant couples:

```{r}
set.seed(1)
rftol_f <- rf_tol1_tol2(df_orig = pheno_funct, mtry = 50, ntree = 10000)
rftol_f
```

Fit a multinomial log linear model to every variable separately:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE, eval = FALSE}
norm_data <- pheno_funct[,c(ncol(pheno_funct), 1:(ncol(pheno_funct)-1))]

## fit a multinomial log linear model to every variable separately,
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)

  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]

  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Save the results (it takes a while to run):
```{r, eval = FALSE}
save(model_stats, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/rd/model_stats.RData")
```

Load the results of modeling for feature selection:
```{r}
norm_data <- pheno_funct[,c(ncol(pheno_funct), 1:(ncol(pheno_funct)-1))]
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/rd/model_stats.RData")
```

Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>%
  group_by(group) %>%
  summarize_if(is.numeric, median) %>%
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Identifying the genes which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
                                                                          non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.7, col = "red")
```

```{r}
goi_dr_100 <- colnames(norm_data)[which(global_aucs >= 0.655)+1]
goi_dr_100
```

I save the AUCs corresponding to these 100 top genes:
```{r}
dr_AUCs <- as.data.frame(goi_dr_100) %>%
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.655)]))

save(dr_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/rd/dr_AUCs.RData")
```

I save the matrix containing the 100 top variables:
```{r}
dr_select <- pheno_funct[,goi_dr_100] %>% 
  rownames_to_column("couple_nb") 

save(dr_select, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/rd/dr_select.RData")
```

Genes that help the most to predict between non-tolerant and primary tolerant couples :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.75)+1]
non_prim_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:
```{r}
dr_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/cyto/r&d/"

correlations_non_prim <- norm_data[,non_prim_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between non-tolerant and secondary tolerant couples :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_sec_genes <- colnames(norm_data)[which(non_sec_aucs >= 0.75)+1]
non_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_non_sec <- norm_data[,non_sec_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(dr_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between primary-tolerant and secondary tolerant couples :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
prim_sec_genes <- colnames(norm_data)[which(prim_sec_aucs >= 0.75)+1]
prim_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_prim_sec <- norm_data[,prim_sec_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.8),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("green", length(nodes$name))


medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["primary_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(dr_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

More global approach: over all genes of interest, no matter if they separate non-tol from primary, non-tol from secondary...
Group the genes that are associated with the outcome (= the "genes of interest") together, by finding the ones that are most correlated between them:

```{r}
genes_of_interest <- colnames(norm_data)[which(global_aucs >= 0.75)+1]
genes_of_interest

correlations <- norm_data[,genes_of_interest] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

correlated_features <- correlations[which(correlations$value > 0.8),]
```

Color the genes that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
gr <- graph_from_data_frame(correlated_features, directed = FALSE)

nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors - recipients:
```{r}
set.seed(1)
rf_r <- ranger::ranger(group~., norm_data[,c("group",genes_of_interest)], mtry = 10, num.trees = 1000,
                           importance = "impurity")
rf_r$confusion.matrix
paste0("prediction error: ", rf_r$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 10, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 10, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the recipients only, on the same backbone:

Load the fcs files and select the files of interest:
```{r}
fcs_dir <- "~/Documents/VIB/Projects/Integrative_Paris/documents_22:02:18/CYTOF_David_Michonneau/fcs/"
fcs_names <- list.files(fcs_dir, pattern="^2.*fcs$")
fcs_names[["R1044"]] <- "20170530_R1044_01_normalized_livecellswithoutbeads__livecells__ADN__time__Ungated_____ICOScleaned__Ungated_"
names(fcs_names) <- gsub("^[0-9]*_([^_]*)_.*", "\\1", fcs_names)
rd_names <- fcs_names[-which(names(fcs_names)%in%c("12R","18R","12D","D1071","D369"))]

## import metadat info :
dataPath <- "~/Documents/VIB/Projects/Integrative_Paris/documents_22:02:18/CYTOF_David_Michonneau/Data synthesis local cohort Saint-Louis 032018_modified.xlsx"
samp_rd <- import_patient_info(data_synthesis_file = dataPath,
                               patient_names = rd_names,
                               patient_type = "donor")

complete_couples <- names(table(samp_rd$COUPLENUMBER))[which(table(samp_rd$COUPLENUMBER)==2)]
complete_names <- rownames(samp_rd)[which(samp_rd$COUPLENUMBER %in% complete_couples)]
recip_names_short <- complete_names[grep("R", complete_names)]
recip_names <- rd_names[recip_names_short]

samp_recip <- samp_rd[names(recip_names),]
```

Isolate only the percentages of the recipients:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/pctgs_meta_rd_automatic_clustering.RData")
pctgs_recip <- pctgs_meta_rd[names(recip_names),]
```

We can then have a closer look at the metaclusters in which the distribution of the patients from the different groups is significantly different:

```{r, echo = FALSE}
group_res <- samp_recip[,"GROUP"]

p_v_meta <- rep(NA, ncol(pctgs_recip))
for (i in seq_len(ncol(pctgs_recip))) {
  data_tmp <- data.frame(Var = pctgs_recip[, i],Visit = group_res)
  #  library(ggplot2)
  #  ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  fit <- aov(Var ~ Visit, data = data_tmp)
  p_v_meta[i] <- summary(fit)[[1]][["Pr(>F)"]][1]
  if(p_v_meta[i] < 0.05){g<-ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  print(g + ggtitle(colnames(pctgs_recip)[i]))}
}
```

We can also look at barplots of the recipients' percentages in the metaclusters of interest:

```{r, echo = FALSE}
different_pops <- colnames(pctgs_recip)[which(p_v_meta<0.05)]

mat2plot <- as.data.frame(pctgs_recip) %>%
rownames_to_column("Id.Cryostem.R") %>%
inner_join(samp_recip, by = "Id.Cryostem.R") %>%
arrange(COUPLENUMBER)

color_vector <- c("#FF0000","#00FF00","#0000FF")[mat2plot$GROUP]

for(metacluster in different_pops){
barplot(mat2plot[,metacluster], col = color_vector,
main = metacluster)
}
plot.new()
legend("center",legend=c("non_tolerant", "secondary_tolerant", "primary_tolerant"),
col=c("#FF0000", "#0000FF", "#00FF00"),
pch=19, cex=1)
```

Extract the ratios of cells that are positive for the functional markers for the recipients only:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/ratios_funct_meta_rd_automatic_clustering.RData")
patient_names <- gsub("^[0-9]*_([^_]*)_.*", "\\1", names(result))
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/funct_mark_res_automatic_clustering.RData")
funct_big_table <- do.call(cbind, tables_res)
rownames(funct_big_table) <- patient_names
funct_recip <- funct_big_table[names(recip_names),]
```

We can then extract the metaclusters in which the distribution of the cells positive for certain functional markers in patients from the different groups is significantly different:

```{r, echo = FALSE}
group_res <- samp_rd[rownames(funct_recip),"GROUP"]

p_v_meta <- rep(NA, ncol(funct_recip))
for (i in seq_len(ncol(funct_recip))) {
  data_tmp <- data.frame(Var = funct_recip[, i],Visit = group_res)
  #  library(ggplot2)
  #  ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  if(all(data_tmp$Var==0)){
    p_v_meta[i] <- 1
  } else {
    fit <- aov(Var ~ Visit, data = data_tmp)
    p_v_meta[i] <- summary(fit)[[1]][["Pr(>F)"]][1]
    if(p_v_meta[i] < 0.005){g<-ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
    print(g + ggtitle(colnames(funct_recip)[i]))}
  }
}
```

We can also look at barplots of the patients' percentages in the metaclusters of interest:

```{r, echo = FALSE}
different_pops <- colnames(funct_recip)[which(p_v_meta<0.005)]

mat2plot <- as.data.frame(funct_recip) %>%
rownames_to_column("Id.Cryostem.R") %>%
inner_join(samp_recip, by = "Id.Cryostem.R") %>%
arrange(COUPLENUMBER)

color_vector <- c("#FF0000","#00FF00","#0000FF")[mat2plot$GROUP]

for(metacluster in different_pops){
barplot(mat2plot[,metacluster], col = color_vector,
main = metacluster)
}
plot.new()
legend("center",legend=c("non_tolerant", "secondary_tolerant", "primary_tolerant"),
col=c("#FF0000", "#0000FF", "#00FF00"),
pch=19, cex=1)
```

Taking together information about the percentages in the FlowSOM metaclusters and the percentage of positive cells for the functional markers in these metaclusters:

```{r, echo = FALSE}
recip_pheno_funct <- merge(as.data.frame(pctgs_recip), as.data.frame(funct_recip), by = "row.names") %>%
  column_to_rownames("Row.names")

pca_recip <- prcomp(as.matrix(recip_pheno_funct))
plot(pca_recip$x)

samp_recip <- samp_recip[rownames(recip_pheno_funct),]
plot(pca_recip$x, col = samp_recip$GROUP)
```


Run RF on phenotypic and functional markers :

```{r}
pheno_funct <- cbind(samp_recip$GROUP, recip_pheno_funct)
colnames(pheno_funct)[1] <- "group"
colnames(pheno_funct) <- make.names(colnames(pheno_funct))
rf_pheno_funct <- randomForest::randomForest(group~., pheno_funct,
                                             mtry = 50, ntree = 10000)
rf_pheno_funct
```

Trying to classify between non tolerant and tolerant recips:

```{r rf_phenof_non_tol_tol}
set.seed(1)
rf2_pf <- rf_tol_non_tol(df_orig = pheno_funct, mtry = 50, ntree = 10000)
rf2_pf
```

Trying to classify between primary and secondary tolerant recips:

```{r rf_phenofunct_tol}
set.seed(1)
rftol_f <- rf_tol1_tol2(df_orig = pheno_funct, mtry = 50, ntree = 10000)
rftol_f
```

Fit a multinomial log linear model to every variable separately:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE, eval = FALSE}
norm_data <- pheno_funct

## fit a multinomial log linear model to every variable separately,
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)

  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]

  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Save the results (it takes a while to run):
```{r, eval = FALSE}
save(model_stats, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/recip/model_stats.RData")
```

Load the results of modeling for feature selection:
```{r}
norm_data <- pheno_funct
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/recip/model_stats.RData")
```

Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>%
  group_by(group) %>%
  summarize_if(is.numeric, median) %>%
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Identifying the genes which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
                                                                          non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.7, col = "red")
```

```{r}
goi_recip_100 <- colnames(norm_data)[which(global_aucs >= 0.66)+1]
goi_recip_100
```

I save the AUCs corresponding to these 100 top genes:
```{r}
recip_AUCs <- as.data.frame(goi_recip_100) %>%
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.66)]))

save(recip_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/compar/recip_AUCs.RData")
```

I save the matrix containing the 100 top variables:
```{r}
recip_select <- pheno_funct[,goi_recip_100] %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  mutate(group = samp_recip$GROUP,
         couple_nb = samp_recip$COUPLENUMBER)

save(recip_select, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/recip/recip_select.RData")
```

Genes that help the most to predict between non-tolerant and primary tolerant couples :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.75)+1]
non_prim_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:
```{r}
recip_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/cyto/recip/"

correlations_non_prim <- norm_data[,non_prim_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(recip_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between non-tolerant and secondary tolerant couples :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_sec_genes <- colnames(norm_data)[which(non_sec_aucs >= 0.75)+1]
non_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_non_sec <- norm_data[,non_sec_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(recip_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between primary-tolerant and secondary tolerant couples :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
prim_sec_genes <- colnames(norm_data)[which(prim_sec_aucs >= 0.75)+1]
prim_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_prim_sec <- norm_data[,prim_sec_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.8),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("green", length(nodes$name))


medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["primary_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(recip_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

More global approach: over all genes of interest, no matter if they separate non-tol from primary, non-tol from secondary...
Group the genes that are associated with the outcome (= the "genes of interest") together, by finding the ones that are most correlated between them:

```{r}
genes_of_interest <- colnames(norm_data)[which(global_aucs >= 0.75)+1]
genes_of_interest

correlations <- norm_data[,genes_of_interest] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

correlated_features <- correlations[which(correlations$value > 0.8),]
```

Color the genes that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
gr <- graph_from_data_frame(correlated_features, directed = FALSE)

nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(recip_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the recipients only:
```{r}
set.seed(1)
rf_r <- ranger::ranger(group~., norm_data[,c("group",genes_of_interest)], mtry = 15, num.trees = 1000,
                           importance = "impurity")
rf_r$confusion.matrix
paste0("prediction error: ", rf_r$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 15, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 15, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors only, on the same backbone:

Load the fcs files and select the files of interest:
```{r}
fcs_dir <- "~/Documents/VIB/Projects/Integrative_Paris/documents_22:02:18/CYTOF_David_Michonneau/fcs/"
fcs_names <- list.files(fcs_dir, pattern="^2.*fcs$")
fcs_names[["R1044"]] <- "20170530_R1044_01_normalized_livecellswithoutbeads__livecells__ADN__time__Ungated_____ICOScleaned__Ungated_"
names(fcs_names) <- gsub("^[0-9]*_([^_]*)_.*", "\\1", fcs_names)
rd_names <- fcs_names[-which(names(fcs_names)%in%c("12R","18R","12D","D1071","D369"))]

## import metadat info :
dataPath <- "~/Documents/VIB/Projects/Integrative_Paris/documents_22:02:18/CYTOF_David_Michonneau/Data synthesis local cohort Saint-Louis 032018_modified.xlsx"
samp_rd <- import_patient_info(data_synthesis_file = dataPath,
                               patient_names = rd_names,
                               patient_type = "donor")

complete_couples <- names(table(samp_rd$COUPLENUMBER))[which(table(samp_rd$COUPLENUMBER)==2)]
complete_names <- rownames(samp_rd)[which(samp_rd$COUPLENUMBER %in% complete_couples)]
donor_names_short <- complete_names[grep("D", complete_names)]
donor_names <- rd_names[donor_names_short]

samp_donor <- samp_rd[names(donor_names),]
```

Isolate only the percentages of the donors:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/pctgs_meta_rd_automatic_clustering.RData")
pctgs_donors <- pctgs_meta_rd[names(donor_names),]
```

We can then have a closer look at the metaclusters in which the distribution of the patients from the different groups is significantly different:

```{r, echo = FALSE}
group_res <- samp_donor[,"GROUP"]

p_v_meta <- rep(NA, ncol(pctgs_donors))
for (i in seq_len(ncol(pctgs_donors))) {
  data_tmp <- data.frame(Var = pctgs_donors[, i],Visit = group_res)
  #  library(ggplot2)
  #  ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  fit <- aov(Var ~ Visit, data = data_tmp)
  p_v_meta[i] <- summary(fit)[[1]][["Pr(>F)"]][1]
  if(p_v_meta[i] < 0.05){g<-ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  print(g + ggtitle(colnames(pctgs_donors)[i]))}
}
```

We can also look at barplots of the donors' percentages in the metaclusters of interest:

```{r, echo = FALSE}
different_pops <- colnames(pctgs_donors)[which(p_v_meta<0.05)]

mat2plot <- as.data.frame(pctgs_donors) %>%
rownames_to_column("Id.Cryostem.R") %>%
inner_join(samp_donor, by = "Id.Cryostem.R") %>%
arrange(COUPLENUMBER)

color_vector <- c("#FF000030","#00FF0030","#0000FF30")[mat2plot$GROUP]

for(metacluster in different_pops){
barplot(mat2plot[,metacluster], col = color_vector,
main = metacluster)
}
plot.new()
legend("center",legend=c("non_tolerant", "secondary_tolerant", "primary_tolerant"),
col=c("#FF000030", "#0000FF30", "#00FF0030"),
pch=19, cex=1)
```

Extract the ratios of cells that are positive for the functional markers for the donors only:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/ratios_funct_meta_rd_automatic_clustering.RData")
patient_names <- gsub("^[0-9]*_([^_]*)_.*", "\\1", names(result))
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/3_backbones/backbone_2_D&Rall/funct_mark_res_automatic_clustering.RData")
funct_big_table <- do.call(cbind, tables_res)
rownames(funct_big_table) <- patient_names
funct_donors <- funct_big_table[names(donor_names),]
```

We can then extract the metaclusters in which the distribution of the cells positive for certain functional markers in patients from the different groups is significantly different:

```{r, echo = FALSE}
group_res <- samp_rd[rownames(funct_donors),"GROUP"]

p_v_meta <- rep(NA, ncol(funct_donors))
for (i in seq_len(ncol(funct_donors))) {
  data_tmp <- data.frame(Var = funct_donors[, i],Visit = group_res)
  #  library(ggplot2)
  #  ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
  if(all(data_tmp$Var==0)){
    p_v_meta[i] <- 1
  } else {
    fit <- aov(Var ~ Visit, data = data_tmp)
    p_v_meta[i] <- summary(fit)[[1]][["Pr(>F)"]][1]
    if(p_v_meta[i] < 0.005){g<-ggplot(data_tmp) + geom_boxplot(aes(x = Visit, y = Var)) + theme_minimal()
    print(g + ggtitle(colnames(funct_donors)[i]))}
  }
}
```

We can also look at barplots of the patients' percentages in the metaclusters of interest:

```{r, echo = FALSE}
different_pops <- colnames(funct_donors)[which(p_v_meta<0.005)]

mat2plot <- as.data.frame(funct_donors) %>%
rownames_to_column("Id.Cryostem.R") %>%
inner_join(samp_donor, by = "Id.Cryostem.R") %>%
arrange(COUPLENUMBER)

color_vector <- c("#FF000040","#00FF0040","#0000FF40")[mat2plot$GROUP]

for(metacluster in different_pops){
barplot(mat2plot[,metacluster], col = color_vector,
main = metacluster)
}
plot.new()
legend("center",legend=c("non_tolerant", "secondary_tolerant", "primary_tolerant"),
col=c("#FF000040", "#0000FF40", "#00FF0040"),
pch=19, cex=1)
```

Taking together information about the percentages in the FlowSOM metaclusters and the percentage of positive cells for the functional markers in these metaclusters:

```{r, echo = FALSE}
donor_pheno_funct <- merge(as.data.frame(pctgs_donors), as.data.frame(funct_donors), by = "row.names") %>%
  column_to_rownames("Row.names")

pca_donor <- prcomp(as.matrix(donor_pheno_funct))
plot(pca_donor$x)

samp_donor <- samp_donor[rownames(donor_pheno_funct),]
plot(pca_donor$x, col = samp_donor$GROUP)
```


Run RF on phenotypic and functional markers :

```{r}
pheno_funct <- cbind(samp_donor$GROUP, donor_pheno_funct)
colnames(pheno_funct)[1] <- "group"
colnames(pheno_funct) <- make.names(colnames(pheno_funct))
rf_pheno_funct <- randomForest::randomForest(group~., pheno_funct,
                                             mtry = 50, ntree = 10000)
rf_pheno_funct
```

Trying to classify between non tolerant and tolerant donors:

```{r donors_rf_phenof_non_tol_tol}
set.seed(1)
rf2_pf <- rf_tol_non_tol(df_orig = pheno_funct, mtry = 50, ntree = 10000)
rf2_pf
```

Trying to classify between primary and secondary tolerant donors:

```{r donors_rf_phenofunct_tol}
set.seed(1)
rftol_f <- rf_tol1_tol2(df_orig = pheno_funct, mtry = 50, ntree = 10000)
rftol_f
```

Fit a multinomial log linear model to every variable separately:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE, eval = FALSE}
norm_data <- pheno_funct

## fit a multinomial log linear model to every variable separately,
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)

  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]

  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Save the results (it takes a while to run):
```{r, eval = FALSE}
save(model_stats, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/donors/model_stats.RData")
```

Load the results of modeling for feature selection:
```{r}
norm_data <- pheno_funct
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/donors/model_stats.RData")
```

Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>%
  group_by(group) %>%
  summarize_if(is.numeric, median) %>%
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Identifying the genes which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
                                                                          non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.7, col = "red")
```

```{r}
goi_donor_100 <- colnames(norm_data)[which(global_aucs >= 0.655)+1]
goi_donor_100
```

I save the AUCs corresponding to these 100 top genes:
```{r}
donor_AUCs <- as.data.frame(goi_donor_100) %>%
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.655)]))

save(donor_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/compar/donor_AUCs.RData")
```

I save the matrix containing the 100 top variables:
```{r}
donor_select <- pheno_funct[,goi_donor_100] %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  mutate(group = samp_donor$GROUP,
         couple_nb = samp_donor$COUPLENUMBER)

save(donor_select, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/donors/donor_select.RData")
```

Genes that help the most to predict between non-tolerant and primary tolerant couples :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.75)+1]
non_prim_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:
```{r}
donor_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/cyto/donors/"

correlations_non_prim <- norm_data[,non_prim_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(donor_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between non-tolerant and secondary tolerant couples :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_sec_genes <- colnames(norm_data)[which(non_sec_aucs >= 0.75)+1]
non_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_non_sec <- norm_data[,non_sec_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(donor_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between primary-tolerant and secondary tolerant couples :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
prim_sec_genes <- colnames(norm_data)[which(prim_sec_aucs >= 0.75)+1]
prim_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_prim_sec <- norm_data[,prim_sec_genes] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.8),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("green", length(nodes$name))


medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["primary_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(donor_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

More global approach: over all variables of interest, no matter if they separate non-tol from primary, non-tol from secondary...
Group the genes that are associated with the outcome (= the "genes of interest") together, by finding the ones that are most correlated between them:

```{r}
genes_of_interest <- colnames(norm_data)[which(global_aucs >= 0.72)+1]
genes_of_interest

correlations <- norm_data[,genes_of_interest] %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  dplyr::filter(var1 < var2)

correlated_features <- correlations[which(correlations$value > 0.8),]
```

Color the genes that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
gr <- graph_from_data_frame(correlated_features, directed = FALSE)

nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(donor_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors only:
```{r}
set.seed(1)
rf_r <- ranger::ranger(group~., norm_data[,c("group",genes_of_interest)], mtry = 15, num.trees = 1000,
                           importance = "impurity")
rf_r$confusion.matrix
paste0("prediction error: ", rf_r$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 15, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 15, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors, recipients, and D-R

Which of the three hold the most information to perform classification?

Plot the AUCs of the 100 top genes from every data source (D, R, D-R)
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/compar/donor_AUCs.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/compar/recip_AUCs.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/cyto/rd/dr_AUCs.RData")

all_aucs <- c(recip_AUCs$auc, dr_AUCs$auc, donor_AUCs$auc)
all_aucs_orig <- c(rep("R", nrow(donor_AUCs)),
                   rep("DR", nrow(recip_AUCs)),
                   rep("D", nrow(dr_AUCs)))
barplot(all_aucs, col = as.factor(all_aucs_orig), ylim = c(0.6, 0.95))
legend("topright", legend = c("Recip_AUCs", "D-R_AUCs", "Donor AUCs"),
       col = c("green", "red", "black"), lty = 1)

barplot(all_aucs[order(all_aucs, decreasing = T)], col = as.factor(all_aucs_orig[order(all_aucs, decreasing = T)]),
        ylim= c(0.6, 0.95))
legend("topright", legend = c("Recip_AUCs", "D-R_AUCs", "D AUCs"),
       col = c("green", "red", "black"), lty = 1)
```

Percentage of every data origin in the top 100 metabolites once sorted per AUC:
```{r}
ordered_aucs_orig <- all_aucs_orig[order(all_aucs, decreasing = T)]
table(ordered_aucs_orig[1:100])
```

Top 100 genes sorted on AUC:
```{r}
colnames(dr_AUCs) = colnames(donor_AUCs) = colnames(recip_AUCs) <- c("top_100_goi", "auc")
dr_AUCs <- dr_AUCs %>%
  mutate(new_names = paste0("DR_", dr_AUCs[,1]))
donor_AUCs <- donor_AUCs %>%
  mutate( new_names = paste0("D_", donor_AUCs[,1]))
recip_AUCs <- recip_AUCs %>%
  mutate(new_names = paste0("R_", recip_AUCs[,1]))

global_aucs <- rbind(recip_AUCs, dr_AUCs, donor_AUCs)
ordered_global_aucs <- global_aucs[order(global_aucs$auc, decreasing = T),]
ordered_global_aucs[1:100,]
```

Venndiagram plot:
```{r}
grid.newpage()
venn.plot <- draw.triple.venn(length(recip_AUCs$auc),
                              length(donor_AUCs$auc),
                              length(dr_AUCs$auc),
                              length(which(recip_AUCs$top_100_goi %in% donor_AUCs$top_100_goi)),
                              length(which(donor_AUCs$top_100_goi %in% dr_AUCs$top_100_goi)),
                              length(which(recip_AUCs$top_100_goi %in% dr_AUCs$top_100_goi)),
                              length(Reduce(intersect, list(recip_AUCs$top_100_goi,
                                                            donor_AUCs$top_100_goi,
                                                            dr_AUCs$top_100_goi))),
                              c("R", "D", "D-R"),
                              fill = c("green", "black", "red"),
                              alpha = rep(0.25, 3),
                              lty = "blank",
                              ind = TRUE)

```
Which are these common variables that overlap in the venndiagram plot?
```{r}
print("Overlap between R and D : ")
recip_AUCs$top_100_goi[which(recip_AUCs$top_100_goi %in% donor_AUCs$top_100_goi)]

print("Overlap between D and D-R : ")
donor_AUCs$top_100_goi[which(donor_AUCs$top_100_goi %in% dr_AUCs$top_100_goi)]

print("Overlap between R and D-R : ")
recip_AUCs$top_100_goi[which(recip_AUCs$top_100_goi %in% dr_AUCs$top_100_goi)]

print("Overalp between all : ")
Reduce(intersect, list(recip_AUCs$top_100_goi,
                       donor_AUCs$top_100_goi,
                       dr_AUCs$top_100_goi))


```

