---
title: "rnaseq_st_louis"
author: "helena"
date: "05/04/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r imports, echo=FALSE, results='hide', warning = FALSE}
suppressPackageStartupMessages({
  library(dplyr)
  library(openxlsx)
  library(metabolomics)
  library(BioGVHD)
  library(tidyverse)
  library(data.table)
  library(dendextend)
  library(ggplot2)
  library(mlbench)
  library(caret)
  library(nnet)
  library(pROC)
  library(igraph)
  library(edgeR)
  library(triwise)
  library(htmlwidgets)
  library(biomaRt)
  library(org.Hs.eg.db) 
  library(clusterProfiler)
  library(VennDiagram)
})
options("scipen"=100)
```


```{r, echo = FALSE}
## Liesbet's and Laetitia's functions
###Get DE genes
getDEgenes<-function(expMatrix, pValCutOff, logFCcutOff){
  topgenes<-expMatrix[expMatrix$adj.P.Val<pValCutOff,]
  genes_up<-topgenes[topgenes$logFC>logFCcutOff,]
  genes_down<-topgenes[topgenes$logFC< -logFCcutOff,]
  ##Sort genes on logFC
  genes_up<-genes_up[order(genes_up$logFC, decreasing=TRUE),]
  genes_down<-genes_down[order(genes_down$logFC, decreasing=TRUE),]
  genes_de_sorted<-rbind(genes_up, genes_down)

  return(genes_de_sorted)
}

###Normalize per gene
normalizePerGene<-function(expMatrix){
  resultMatrix<-t(apply(expMatrix, 1, function(x)(x-min(x))/(max(x)-min(x))))

  return(resultMatrix)
}

## convert to Entrez Id
convertIDs <- function( ids, fromKey, toKey, db, ifMultiple=c( "putNA", "useFirst" ) ) {
stopifnot( inherits( db, "AnnotationDb" ) )
ifMultiple <- match.arg( ifMultiple )
suppressWarnings( selRes <- AnnotationDbi::select( 
db, keys=ids, keytype=fromKey, columns=c(fromKey,toKey) ) )
if( ifMultiple == "putNA" ) {
duplicatedIds <- selRes[ duplicated( selRes[,1] ), 1 ] 
selRes <- selRes[ ! selRes[,1] %in% duplicatedIds, ] }
return( selRes[ match( ids, selRes[,1] ), 2 ] )
}
```

## RNA seq analysis of the St Louis cohort

I first read in the rawa data:

```{r read_data_st_louis}
countData<-read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/Local_cohort/RNAseq/Global_table_StLouis_completed.xlsx")
colnames(countData) <- as.character(countData[1,]) # set patient names as colnames
rownames(countData) <- countData$ID # set gene names as rownames
countData_withinfo <- countData[,-1]
```

I can then look at the extra information on the patients' unmapped genes, lib size, ...

```{r}
## Look at the info on samples:
plot(as.numeric(countData_withinfo[2,]), ylab = "unmapped genes", xlab = "patients")
plot(as.numeric(countData_withinfo[3,]), ylab = rownames(countData)[3], xlab = "patients")
above <- which(as.numeric(countData_withinfo[3,]) > 8*10^6)
colnames(countData_withinfo)[above]
plot(as.numeric(countData_withinfo[4,]), ylab = rownames(countData)[4], xlab = "patients")
plot(as.numeric(countData_withinfo[5,]), ylab = rownames(countData)[5], xlab = "patients")
colnames(countData_withinfo)[which(as.numeric(countData_withinfo[5,]) > 5*10^6)]
# [1] "D708"

countData <- countData[6:nrow(countData), 2:ncol(countData)] # rm the informations on unmapped, ambiguous...
dim(countData)
```

It seems like the patient "D708" might be a problematic sample, I keep it in mind for the rest of the analysis.

I then load in the clinical data, and reorder the RNAseq and clinical data tables so that they are in the same order:

```{r}
colData<-read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/Local_cohort/Data synthesis local cohort Saint-Louis 17012019.xlsx")
colData <- colData[!is.na(colData$RNAseq.ID),] # remove rows with no RNAseq sample
rownames(colData) <- colData$Id.Cryostem.R

### Reorder
countData<-countData[,rownames(colData)]
```

I then identify the donors and recipients, for which we have complete cases:
```{r}
complete_couples <- colData$COUPLENUMBER[which(duplicated(colData$COUPLENUMBER))]

complete_names <- rownames(colData)[which(colData$COUPLENUMBER %in% complete_couples)]
donor_names <- complete_names[grep("D", complete_names)]
donor_id <- which(colnames(countData) %in% donor_names)

recip_names <- complete_names[grep("R", complete_names)]
recip_id <- which(colnames(countData) %in% recip_names)
```


## Analysis on the recipients

### Preprocessing :

I will first focus on the recipients only, and perform a standard preprocessing (keep genes with more than one count per million in at least three patients:

```{r preproc_recip, echo=FALSE, eval = FALSE}
counts <- countData[,c(recip_id)]

count_nb <- apply(counts,2,as.numeric) # turn characters into numerics
rownames(count_nb) <- rownames(counts) # restore the rownmes which were lost in the transfo
counts <- count_nb

### Preprocessing
y <- DGEList(counts = counts)
keep = rowSums(cpm(y)>1) >= 3
y = y[keep,]
dim(y) # from 69000 genes to 18000 genes after this filter

# Reset lib sizes
y$samples$lib.size = colSums(y$counts)
```

The names of the genes are in the ensembl ID format. When possible, I replace them with the associated gene symbol:
```{r, eval = FALSE}
##CONVERT ENSEMBL GENE NAME TO ENTREZID & SYMBOL
hgnc_symbol <- convertIDs( rownames(y$counts), "ENSEMBL", "SYMBOL", org.Hs.eg.db )

counts_gene_symbol <- y$counts
names_2change <- hgnc_symbol[-which(is.na(hgnc_symbol))]
names_2keep_idx <- which(is.na(hgnc_symbol))
dupp <- names_2change[which(duplicated(names_2change))]
dupp_idx <- which(hgnc_symbol %in% dupp)[c(T,F)]
final_ids_2keep <- c(names_2keep_idx, dupp_idx)

rownames(counts_gene_symbol)[-final_ids_2keep] <- hgnc_symbol[-final_ids_2keep]

y$counts <- counts_gene_symbol
```

Perform normalisation and initiate the design matrix (per group)

```{r, eval = FALSE}
# compute norm_factors
normfac <- calcNormFactors(y, method = "TMM")

#### Create design matrix
# for the three groups :
patient_groups <- tolower(colData$GROUP)
TS <- patient_groups[c(recip_id)]

TS <- factor(TS, levels=unique(TS))
design <- model.matrix(~0+TS)
colnames(design) <- levels(TS)
design

#voom
#In limma, read counts are converted to log2-counts-per-million (logCPM) and
#the mean-variance relationship is modelled either with precision weights or
#with an empirical Bayes prior trend. The precision weights approach is called “voom”
# lib.size <- counts$samples$lib.size * counts$samples$norm.factors
# E <- t(log2(t(counts + 0.5)/(lib.size + 1) * 1e+06))
v <- voom(y, design, plot = TRUE)
expTable<-v$E
```

Save the produced objects:

```{r, eval = FALSE}
DE_list <- list(v, y, design)

save(expTable, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/expression_table_recip.RData")
save(DE_list, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/data_for_DE_recip.RData")
```

Load the produced data :
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/expression_table_recip.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/data_for_DE_recip.RData")
```

### Differential Analysis 

Fit a model to the design:
```{r}
names(DE_list) <- c("v", "y", "design")
fit <- lmFit(DE_list$v, DE_list$design)

#### Create contrast matrix
cont.matrix <- makeContrasts(group1=non_tolerant-primary_tolerant,
                             group2=non_tolerant-secondary_tolerant,
                             group3=primary_tolerant-secondary_tolerant,
                             levels=DE_list$design)
cont.matrix
fit2 = contrasts.fit(fit, cont.matrix)

#### Moderate T-test with 'shrunken' se
fit.eb <- eBayes(fit2)
```

Adjust the pvalues for multiple testing :
```{r}
#### Adjust P-values via Benjamini-Hochberg
##### 1. non-tol vs tol-1
allGenesGroup1<-topTable(fit.eb, adjust="BH", sort.by="P",number=Inf, coef=1)
DEgenesGroup1<-getDEgenes(allGenesGroup1,0.05,1)
dim(DEgenesGroup1)
##84

##### 2. non-tol vs tol-2
allGenesGroup2<-topTable(fit.eb, adjust="BH", sort.by="P",number=Inf, coef=2)
DEgenesGroup2<-getDEgenes(allGenesGroup2,0.05,1)
dim(DEgenesGroup2)
##57

##### 3. tol-1 vs tol-2
allGenesGroup3<-topTable(fit.eb, adjust="BH", sort.by="P",number=Inf, coef=3)
DEgenesGroup3<-getDEgenes(allGenesGroup3,0.05,1)
dim(DEgenesGroup3)
##0
```

Plot a triwise plot and save an interactive triwise plot:
```{r}
##### All DE genes #####
allDEgenes<-unique(c(rownames(DEgenesGroup1),rownames(DEgenesGroup2),rownames(DEgenesGroup3)))
length(allDEgenes)
##122

wantedColors<-c(nodiffall="#FFFFFF80",diffall="indianred1")

design <- DE_list$design
##### Triwise plots
non_tol_mean<-apply(expTable[,as.numeric(which(design[,1]==1))],1,mean)
tol1_mean<-apply(expTable[,as.numeric(which(design[,2]==1))],1,mean)
tol2_mean<-apply(expTable[,as.numeric(which(design[,3]==1))],1,mean)

expTable_mean<-cbind(non_tol_mean, tol1_mean, tol2_mean)
colnames(expTable_mean)<-c('Non_tol','Primary_tol','Secondary_tol')

theBarycoords<-transformBarycentric(expTable_mean)
wantedColors<-c(nodiffall="#FFFFFF00",diffall="indianred1")

barycoords = theBarycoords
Gdiffexp = allDEgenes

###Triwise plot
### Plot only the DEgenes, to "clean up" the plots a bit:
expDE_mean <- expTable_mean[allDEgenes,]
DEBarycoords<-transformBarycentric(expDE_mean)
p<-plotDotplot(DEBarycoords, Gdiffexp=allDEgenes, colorvalues=wantedColors,
               showlabels = F, rmax = 4)
print(p)
```


```{r, eval = FALSE}
#######################
### Plot only the DEgenes, to "clean up" the plots a bit:
expDE_mean <- expTable_mean[allDEgenes,]
DEBarycoords<-transformBarycentric(expDE_mean)
p<-interactiveDotplot(expDE_mean, Gdiffexp=allDEgenes, plotLocalEnrichment=FALSE,
                      rmax = 4)
saveWidget(p,file="~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/interactiveTriwisePlot_filtered_DEgenes_all_organs.html")
```


### Machine learning approach :

filter out lowly variable genes:

```{r}
sds <- apply(expTable,1,sd)
plot(sort(sds), type = "l")
abline(h=quantile(sds, 0.5), col="red")
expT <- expTable[which(sds>=quantile(sds, 0.5)),]
rnames <- rownames(expT)
expT <- apply(expT,2,as.numeric)
rownames(expT) <- rnames
```


Prepare the data:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE}

norm_data <- t(expT)
patient_groups <- tolower(colData$GROUP)
group <- patient_groups[c(recip_id)]
norm_data <- as.data.frame(norm_data) %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  mutate(group = group) %>% 
  column_to_rownames("Id.Cryostem.R") %>% 
  dplyr::select(group, rownames(expT))
norm_data[,1] <- as.factor(norm_data[,1])
colnames(norm_data) <- make.names(colnames(norm_data))
```

PCA on the recipients to see if there isn't too much batch effect:
```{r}
colData_recip <- colData[c(recip_id),]

pca <- prcomp(norm_data[,-1])
plot(pca$x, col = as.factor(tolower(colData_recip$GROUP)))
plot(pca$x, col = as.factor(colData_recip$RNAseq.RUN))
```

Random forest on the normalised data of the recipients only:
```{r}
set.seed(1)
rf_recip <- ranger::ranger(group~., norm_data, mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_recip$confusion.matrix
rf_recip$prediction.error*100
```

Variables of interest according to the random forest model:
```{r}
goi_rf_recip <- names(sort(rf_recip$variable.importance, decreasing = T)[1:260])
head(goi_rf_recip, 100)
```

Do we retrieve the genes that we had found in the DE analysis?
```{r}
DE_rf_genes <- allDEgenes[which(allDEgenes %in% goi_rf_recip)]
print(paste0("Number of DE genes: ", length(allDEgenes)))
print(paste0("Number of selected top importance genes in the random forest: ", length(goi_rf_recip)))
print(paste0("Number of genes that are common between the two: ", length(which(allDEgenes %in% goi_rf_recip))))
allDEgenes[which(allDEgenes %in% goi_rf_recip)]
```

Fit a multinomial log linear model to every variable separately:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE, eval = FALSE}
## fit a multinomial log linear model to every variable separately,
## and extract the residual deviance (what has not been explained by the variable):
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)
  
  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]
  
  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Save the results (it takes a while to run):
```{r, eval = FALSE}
save(model_stats, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/model_stats.RData")
```

Load the results of modeling for feature selection:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/model_stats.RData")
```


Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>% 
  group_by(group) %>% 
  summarize_if(is.numeric, median) %>% 
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Identifying the genes which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.7, col = "red")
```

```{r}
genes_of_interest <- colnames(norm_data)[which(global_aucs >= 0.76)+1]
genes_of_interest
```

Do we retrieve the genes that we had found in the DE analysis?
```{r}
print(paste0("Number of DE genes: ", length(allDEgenes)))
print(paste0("Number of genes of interest: ", length(genes_of_interest)))
print(paste0("Number of genes that are common between the two: ", length(which(allDEgenes %in% genes_of_interest))))
```

Do we retrieve the genes that we found in the random forest?
```{r}
goi_rf_genes <- genes_of_interest[which(genes_of_interest %in% goi_rf_recip)]
print(paste0("Number of genes of interest: ", length(genes_of_interest)))
print(paste0("Number of selected top importance genes in the random forest: ", length(goi_rf_recip)))
print(paste0("Number of genes that are comon between the two: ", length(which(genes_of_interest %in% goi_rf_recip))))
```

Are these 111 genes the same as the ones that were common between rf and DE?
```{r}
length(which(goi_rf_genes %in% DE_rf_genes))
```


```{r}
goi_recip_100 <- colnames(norm_data)[which(global_aucs >= 0.791)+1]
goi_recip_100
```

I save the AUCs corresponding to these 100 top genes:
```{r}
recip_AUCs <- as.data.frame(goi_recip_100) %>% 
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.791)]))
  
save(recip_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/compar/recip_AUCs.RData")
```

I save the matrix containing the 100 top variables:
```{r}
recip_select <- norm_data[,goi_recip_100] %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  mutate(group = colData_recip$GROUP,
         couple_nb = colData_recip$COUPLENUMBER)

save(recip_select, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/recip_only/recip_select.RData")
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
colnames(norm_data)[1] <- "group"
norm_data$group <- as.factor(tolower(norm_data$group))

set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data, mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data, mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", rf_tol$prediction.error*100)
```

genes that help the most to predict between non-tolerant and primary tolerant recipients :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.89, col = "red")
```

```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.89)+1]
non_prim_genes
```

Which of these genes can be grouped together?
The genes are colored in yellow in the graph because they correspond to the genes which most differ between non tolerant patients (that I always represent in red) and primary tolerant patients (that I always represent in green).
```{r}
correlations_non_prim <- norm_data[,non_prim_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = "yellow")

```

Color the genes that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:

```{r}
recip_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/rnaseq/recip/"

nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(recip_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
```

I apply a stricter threshold to select only the most important genes for classification:
```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.89)+1]
non_prim_genes
```

Which of these genes can be grouped together?
The genes that are more expressed in the primary tolerant patients are in green, and the ones that are more expressed in the non tolerant patients are colored in red.
```{r}
correlations_non_prim <- norm_data[,non_prim_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(recip_path, "NP2.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)

```



Genes that help the most to predict between non-tolerant and secondary tolerant recipients :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.89, col = "red")
```

```{r}
non_sec_genes <- colnames(norm_data)[which(non_sec_aucs >= 0.89)+1]
non_sec_genes
```

Which of these genes can be grouped together?
The genes that are more expressed in the secondary tolerant patients are in blue, and the ones that are more expressed in the non tolerant patients are colored in red.
```{r}
correlations_non_sec <- norm_data[,non_sec_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(recip_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between primary-tolerant and secondary tolerant recipients :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.89, col = "red")
```

```{r}
prim_sec_genes <- colnames(norm_data)[which(prim_sec_aucs >= 0.89)+1]
prim_sec_genes
```

Which of these genes can be grouped together?
The genes that are more expressed in the secondary tolerant patients are in blue, and the ones that are more expressed in the prim tolerant patients are colored in green.
```{r}
correlations_prim_sec <- norm_data[,prim_sec_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.8),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("green", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["primary_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(recip_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

More global approach: over all genes of interest, no matter if they separate non-tol from primary, non-tol from secondary... 
Group the genes that are associated with the outcome (= the "genes of interest") together, by finding the ones that are most correlated between them:

```{r}
correlations <- norm_data[,genes_of_interest] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)
```


```{r}
correlated_features <- correlations[which(correlations$value > 0.8),]
```

```{r}
library(igraph)
gr <- graph_from_data_frame(correlated_features, directed = FALSE)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20)
```

Color the genes that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(recip_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the recipients only:
```{r}
set.seed(1)
rf_donor <- ranger::ranger(group~., norm_data[,c("group", genes_of_interest)], mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_donor$confusion.matrix
paste0("prediction error: ", rf_donor$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors only :

```{r preproc_donors, echo=FALSE, eval = FALSE}
counts <- countData[,c(donor_id)]

count_nb <- apply(counts,2,as.numeric) # turn characters into numerics
rownames(count_nb) <- rownames(counts) # restore the rownmes which were lost in the transfo
counts <- count_nb

### Preprocessing
y <- DGEList(counts = counts)
keep = rowSums(cpm(y)>1) >= 3
y = y[keep,]
dim(y) # from 69000 genes to 18000 genes after this filter

# Reset lib sizes
y$samples$lib.size = colSums(y$counts)
```

The names of the genes are in the ensembl ID format. When possible, I replace them with the associated gene symbol:
```{r, eval = FALSE}
##CONVERT ENSEMBL GENE NAME TO ENTREZID & SYMBOL
hgnc_symbol <- convertIDs( rownames(y$counts), "ENSEMBL", "SYMBOL", org.Hs.eg.db )

counts_gene_symbol <- y$counts
names_2change <- hgnc_symbol[-which(is.na(hgnc_symbol))]
names_2keep_idx <- which(is.na(hgnc_symbol))
dupp <- names_2change[which(duplicated(names_2change))]
dupp_idx <- which(hgnc_symbol %in% dupp)[c(T,F)]
final_ids_2keep <- c(names_2keep_idx, dupp_idx)

rownames(counts_gene_symbol)[-final_ids_2keep] <- hgnc_symbol[-final_ids_2keep]

y$counts <- counts_gene_symbol
```
Perform normalisation and initiate the design matrix (per group)

```{r, eval = FALSE}
# compute norm_factors
normfac <- calcNormFactors(y, method = "TMM")

#### Create design matrix
# for the three groups :
patient_groups <- tolower(colData$GROUP)
TS <- patient_groups[c(donor_id)]

TS <- factor(TS, levels=unique(TS))
design <- model.matrix(~0+TS)
colnames(design) <- levels(TS)
design

#voom
#In limma, read counts are converted to log2-counts-per-million (logCPM) and
#the mean-variance relationship is modelled either with precision weights or
#with an empirical Bayes prior trend. The precision weights approach is called “voom”
# lib.size <- counts$samples$lib.size * counts$samples$norm.factors
# E <- t(log2(t(counts + 0.5)/(lib.size + 1) * 1e+06))
v <- voom(y, design, plot = TRUE)
expTable<-v$E
```

Save the produced objects:

```{r, eval = FALSE}
DE_list <- list(v, y, design)

save(expTable, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/expression_table_donors.RData")
save(DE_list, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/data_for_DE_donors.RData")
```

Load the produced data :
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/expression_table_donors.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/data_for_DE_donors.RData")
```

### Differential Analysis 

Fit a model to the design:
```{r}
names(DE_list) <- c("v", "y", "design")
fit <- lmFit(DE_list$v, DE_list$design)

#### Create contrast matrix
cont.matrix <- makeContrasts(group1=non_tolerant-primary_tolerant,
                             group2=non_tolerant-secondary_tolerant,
                             group3=primary_tolerant-secondary_tolerant,
                             levels=DE_list$design)
cont.matrix
fit2 = contrasts.fit(fit, cont.matrix)

#### Moderate T-test with 'shrunken' se
fit.eb <- eBayes(fit2)
```

Adjust the pvalues for multiple testing :
```{r}
#### Adjust P-values via Benjamini-Hochberg
##### 1. non-tol vs tol-1
allGenesGroup1<-topTable(fit.eb, adjust="BH", sort.by="P",number=Inf, coef=1)
DEgenesGroup1<-getDEgenes(allGenesGroup1,0.05,1)
dim(DEgenesGroup1)
##84

##### 2. non-tol vs tol-2
allGenesGroup2<-topTable(fit.eb, adjust="BH", sort.by="P",number=Inf, coef=2)
DEgenesGroup2<-getDEgenes(allGenesGroup2,0.05,1)
dim(DEgenesGroup2)
##57

##### 3. tol-1 vs tol-2
allGenesGroup3<-topTable(fit.eb, adjust="BH", sort.by="P",number=Inf, coef=3)
DEgenesGroup3<-getDEgenes(allGenesGroup3,0.05,1)
dim(DEgenesGroup3)
##0
```

### Machine learning approach :

filter out lowly variable genes:

```{r}
sds <- apply(expTable,1,sd)
plot(sort(sds), type = "l")
abline(h=quantile(sds, 0.5), col="red")
expT <- expTable[which(sds>=quantile(sds, 0.5)),]
rnames <- rownames(expT)
expT <- apply(expT,2,as.numeric)
rownames(expT) <- rnames
```

Prepare the data:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE}
norm_data <- t(expT)
patient_groups <- tolower(colData$GROUP)
group <- patient_groups[c(donor_id)]
norm_data <- as.data.frame(norm_data) %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  mutate(group = group) %>% 
  column_to_rownames("Id.Cryostem.R") %>% 
  dplyr::select(group, rownames(expT))
norm_data[,1] <- as.factor(norm_data[,1])
colnames(norm_data) <- make.names(colnames(norm_data))
```

PCA on the donors to see if there isn't too much batch effect:
```{r}
colData_donor <- colData[c(donor_id),]

pca <- prcomp(norm_data[,-1])
plot(pca$x, col = as.factor(tolower(colData_donor$GROUP)))
plot(pca$x, col = as.factor(colData_donor$RNAseq.RUN))
```

Random forest on the normalised data of the donors only:
```{r}
set.seed(1)
rf_donor <- ranger::ranger(group~., norm_data, mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_donor$confusion.matrix
rf_donor$prediction.error*100
```

Variables of interest according to the random forest model:
```{r}
goi_rf_donor <- names(sort(rf_donor$variable.importance, decreasing = T)[1:100])
head(goi_rf_donor, 100)
```

Fit a multinomial log linear model to every variable separately:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE, eval = FALSE}
## fit a multinomial log linear model to every variable separately,
## and extract the residual deviance (what has not been explained by the variable):
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)
  
  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]
  
  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Save the results (it takes a while to run):
```{r, eval = FALSE}
save(model_stats, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/model_stats.RData")
```

Load the results of modeling for feature selection:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/model_stats.RData")
```


Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>% 
  group_by(group) %>% 
  summarize_if(is.numeric, median) %>% 
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Identifying the genes which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.767, col = "red")
```

```{r}
goi_donor_100 <- colnames(norm_data)[which(global_aucs >= 0.771)+1]
goi_donor_100
```

Do we retrieve the genes that we found in the random forest?
```{r}
print(paste0("Number of genes of interest: ", length(goi_donor_100)))
print(paste0("Number of selected top importance genes in the random forest: ", length(goi_rf_donor)))
print(paste0("Number of genes that are comon between the two: ", length(which(goi_donor_100 %in% goi_rf_donor))))
```

I save the AUCs corresponding to these 100 top genes:
```{r}
donor_AUCs <- as.data.frame(goi_donor_100) %>% 
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.771)]))
  
save(donor_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/compar/donor_AUCs.RData")
```

I save the matrix containing the 100 top variables:
```{r}
donor_select <- norm_data[,goi_donor_100] %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  mutate(group = colData_donor$GROUP,
         couple_nb = colData_donor$COUPLENUMBER)

save(donor_select, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_only/donor_select.RData")
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
colnames(norm_data)[1] <- "group"
norm_data$group <- as.factor(tolower(norm_data$group))

set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data, mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data, mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

Genes that help the most to predict between non-tolerant and primary tolerant couples :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.88, col = "red")
```

```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.88)+1]
non_prim_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:
```{r}
donor_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/rnaseq/donors/"

corr_non_prim <- norm_data[,non_prim_genes]

correlations_non_prim <- norm_data[,non_prim_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))

gr_med <- gr_medians

medians <- gr_med[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(donor_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between non-tolerant and secondary tolerant couples :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.76, col = "red")
```

```{r}
non_sec_genes <- colnames(norm_data)[which(non_sec_aucs >= 0.76)+1]
non_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
corr_non_sec <- norm_data[,non_sec_genes]

correlations_non_sec <- norm_data[,non_sec_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))

gr_med <- gr_medians

medians <- gr_med[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(donor_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between primary tolerant and secondary tolerant couples :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.86, col = "red")
```

```{r}
prim_sec_genes <- colnames(norm_data)[which(prim_sec_aucs >= 0.86)+1]
prim_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secary tolerant patients in blue, and the ones that are more expressed in the prim tolerant patients in red:
```{r}
corr_prim_sec <- norm_data[,prim_sec_genes]

correlations_prim_sec <- norm_data[,prim_sec_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.8),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("green", length(nodes$name))

gr_med <- gr_medians

medians <- gr_med[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["primary_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(donor_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Color the genes that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
goi_donor <- colnames(norm_data)[which(global_aucs >= 0.771)+1]

correlations <- norm_data[,goi_donor] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

correlated_features <- correlations[which(correlations$value > 0.8),]

gr <- graph_from_data_frame(correlated_features, directed = FALSE)

nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(donor_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors only:
```{r}
set.seed(1)
rf_donor <- ranger::ranger(group~., norm_data[,c("group", goi_donor)], mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_donor$confusion.matrix
paste0("prediction error: ", rf_donor$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", goi_donor)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", goi_donor)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors - recipients

```{r preproc_d_r, echo=FALSE}
counts <- countData[,c(donor_id, recip_id)]

count_nb <- apply(counts,2,as.numeric) # turn characters into numerics
rownames(count_nb) <- rownames(counts) # restore the rownmes which were lost in the transfo
counts <- count_nb

# Keep only the patients that form complete cases (donor + recipient)

colData_rd <- colData[colnames(counts),]
complete_couples <- colData_rd$COUPLENUMBER[which(duplicated(colData_rd$COUPLENUMBER))]
counts <- counts[,which(colData_rd$COUPLENUMBER %in% complete_couples)]

colData_rd <- colData_rd[colnames(counts),]

### Preprocessing
y <- DGEList(counts = counts)
keep = rowSums(cpm(y)>1) >= 3
y = y[keep,]
dim(y) # from 69000 genes to 18000 genes after this filter

# Reset lib sizes
y$samples$lib.size = colSums(y$counts)
```

The names of the genes are in the ensembl ID format. When possible, I replace them with the associated gene symbol:
```{r, eval = FALSE}
##CONVERT ENSEMBL GENE NAME TO ENTREZID & SYMBOL
hgnc_symbol <- convertIDs( rownames(y$counts), "ENSEMBL", "SYMBOL", org.Hs.eg.db )

counts_gene_symbol <- y$counts
names_2change <- hgnc_symbol[-which(is.na(hgnc_symbol))]
names_2keep_idx <- which(is.na(hgnc_symbol))
dupp <- names_2change[which(duplicated(names_2change))]
dupp_idx <- which(hgnc_symbol %in% dupp)[c(T,F)]
final_ids_2keep <- c(names_2keep_idx, dupp_idx)

rownames(counts_gene_symbol)[-final_ids_2keep] <- hgnc_symbol[-final_ids_2keep]

y$counts <- counts_gene_symbol
```

Perform normalisation and initiate the design matrix (per group)

```{r, eval = FALSE}
# compute norm_factors
normfac <- calcNormFactors(y, method = "TMM")

#### Create design matrix
# for the three groups :
TS <- tolower(colData_rd$GROUP)

TS <- factor(TS, levels=unique(TS))
design <- model.matrix(~0+TS)
colnames(design) <- levels(TS)
design

#voom
#In limma, read counts are converted to log2-counts-per-million (logCPM) and
#the mean-variance relationship is modelled either with precision weights or
#with an empirical Bayes prior trend. The precision weights approach is called “voom”
# lib.size <- counts$samples$lib.size * counts$samples$norm.factors
# E <- t(log2(t(counts + 0.5)/(lib.size + 1) * 1e+06))
v <- voom(y, design, plot = TRUE)
expTable<-v$E
```

Save the produced objects:

```{r, eval = FALSE}
DE_list <- list(v, y, design)

save(expTable, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/expression_table_dr.RData")
save(DE_list, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/data_for_DE_dr.RData")
```

Load the data :
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/expression_table_dr.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/data_for_DE_dr.RData")

big_mat <- as.data.frame(t(expTable)) %>% 
  rownames_to_column("Id.Cryostem.R") %>% 
  left_join(colData, by = "Id.Cryostem.R")

#big_mat <- big_mat[which(duplicated(big_mat$COUPLENUMBER)),]

vars2rm <- colnames(colData)[-c(1, 4)]
big_mat2 <- big_mat %>%
  group_by(COUPLENUMBER) %>%
  dplyr::select(-vars2rm)

subst <- big_mat2 %>%
  summarise_if(is.numeric, ~.[1]-.[2])

colData_tmp <- colData[big_mat2$Id.Cryostem.R,]
colData_tmp$GROUP <- as.factor(tolower(colData_tmp$GROUP))
colData_subst <- colData_tmp %>% 
  arrange(COUPLENUMBER) %>% 
  dplyr::select(c("GROUP", "COUPLENUMBER")) %>% 
  unique()

subst <- subst %>% 
  mutate("couple" = paste0("couple_",COUPLENUMBER),
         "group" = colData_subst$GROUP) %>% 
  column_to_rownames("couple") %>% 
  dplyr::select (-"COUPLENUMBER") 

subst <- subst[,c(ncol(subst), 1:(ncol(subst)-1))]

colnames(subst) <- make.names(colnames(subst))
colnames(subst)[-1] <- paste0("subst_", colnames(subst))[-1]
```


### Machine learning approach :

filter out lowly variable genes:

```{r}
sds <- apply(subst[,-1],2,sd)
plot(sort(sds), type = "l")
abline(h=quantile(sds, 0.5), col="red")
expT <- subst[,which(sds>=quantile(sds, 0.5))+1]
rnames <- rownames(expT)
expT <- apply(expT,2,as.numeric)
rownames(expT) <- rnames
```

Prepare the data:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE}
norm_data <- expT
group <- subst$group
norm_data <- as.data.frame(norm_data) %>% 
  rownames_to_column("couple_nb") %>% 
  mutate(group = group) %>% 
  column_to_rownames("couple_nb") %>% 
  dplyr::select(group, colnames(expT))
norm_data[,1] <- as.factor(norm_data[,1])
colnames(norm_data) <- make.names(colnames(norm_data))

```

PCA on the recipients to see if there isn't too much batch effect:
```{r}
pca <- prcomp(norm_data[,-1])
plot(pca$x, col = as.factor(tolower(colData_subst$GROUP)))
```

Random forest on the normalised data of the donors - recipients:
```{r}
set.seed(1)
rf_dr <- ranger::ranger(group~., norm_data, mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_dr$confusion.matrix
rf_dr$prediction.error
```

Variables of interest according to the random forest model:
```{r}
goi_rf_dr <- names(sort(rf_dr$variable.importance, decreasing = T)[1:100])
head(goi_rf_dr, 100)
```

Fit a multinomial log linear model to every variable separately:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE, eval = FALSE}
## fit a multinomial log linear model to every variable separately,
## and extract the residual deviance (what has not been explained by the variable):
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)
  
  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]
  
  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Save the results (it takes a while to run):
```{r, eval = FALSE}
save(model_stats, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/model_stats.RData")
```

Load the results of modeling for feature selection:
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/model_stats.RData")
```


Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>% 
  group_by(group) %>% 
  summarize_if(is.numeric, median) %>% 
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Identifying the genes which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.79, col = "red")
```

```{r}
goi_dr_100 <- colnames(norm_data)[which(global_aucs >= 0.779)+1]
goi_dr_100
```

Do we retrieve the genes that we found in the random forest?
```{r}
print(paste0("Number of genes of interest: ", length(goi_dr_100)))
print(paste0("Number of selected top importance genes in the random forest: ", length(goi_rf_dr)))
print(paste0("Number of genes that are comon between the two: ", length(which(goi_dr_100 %in% goi_rf_dr))))
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
colnames(norm_data)[1] <- "group"
norm_data$group <- as.factor(tolower(norm_data$group))

set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data, mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data, mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

I save the AUCs corresponding to these 100 top genes:
```{r}
dr_AUCs <- as.data.frame(goi_dr_100) %>% 
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.779)]))
  
save(dr_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/compar/dr_AUCs.RData")
```

I save the matrix containing the 100 top variables:
```{r}
dr_select <- norm_data[,goi_dr_100] %>% 
  mutate(group = colData_subst$GROUP,
         couple_nb = colData_subst$COUPLENUMBER)

save(dr_select, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/donors_and_recip/dr_select.RData")
```

Genes that help the most to predict between non-tolerant and primary tolerant couples :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.9, col = "red")
```

```{r}
non_prim_genes <- colnames(norm_data)[which(non_prim_aucs >= 0.87)+1]
non_prim_genes
```


Which of these genes can be grouped together?
the genes that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:
```{r}
dr_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/rnaseq/d-r/"

correlations_non_prim <- norm_data[,non_prim_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between non-tolerant and secondary tolerant couples :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.87, col = "red")
```

```{r}
non_sec_genes <- colnames(norm_data)[which(non_sec_aucs >= 0.87)+1]
non_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_non_sec <- norm_data[,non_sec_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))

medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(dr_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Genes that help the most to predict between primary-tolerant and secondary tolerant couples :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.9, col = "red")
```

```{r}
prim_sec_genes <- colnames(norm_data)[which(prim_sec_aucs >= 0.87)+1]
prim_sec_genes
```

Which of these genes can be grouped together?
the genes that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_prim_sec <- norm_data[,prim_sec_genes] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.8),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)
nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("green", length(nodes$name))


medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["primary_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(dr_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

More global approach: over all genes of interest, no matter if they separate non-tol from primary, non-tol from secondary... 
Group the genes that are associated with the outcome (= the "genes of interest") together, by finding the ones that are most correlated between them:

```{r}
genes_of_interest <- colnames(norm_data)[which(global_aucs >= 0.77)+1]
genes_of_interest

correlations <- norm_data[,genes_of_interest] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

correlated_features <- correlations[which(correlations$value > 0.8),]
```

Color the genes that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
gr <- graph_from_data_frame(correlated_features, directed = FALSE)

nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors - recipients :
```{r}
set.seed(1)
rf_dr <- ranger::ranger(group~., norm_data[,c("group", genes_of_interest)], mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_dr$confusion.matrix
paste0("prediction error: ", rf_dr$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", genes_of_interest)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors, recipients, and D-R

Which of the three hold the most information to perform classification?

Plot the AUCs of the 100 top genes from every data source (D, R, D-R)
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/compar/donor_AUCs.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/compar/recip_AUCs.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/RNAseq/compar/dr_AUCs.RData")

all_aucs <- c(recip_AUCs$auc, dr_AUCs$auc, donor_AUCs$auc)
all_aucs_orig <- c(rep("R", nrow(donor_AUCs)),
                   rep("DR", nrow(recip_AUCs)),
                   rep("D", nrow(dr_AUCs)))
barplot(all_aucs, col = as.factor(all_aucs_orig), ylim = c(0.6, 0.95))
legend("topright", legend = c("Recip_AUCs", "D-R_AUCs", "Donor AUCs"),
      col = c("green", "red", "black"), lty = 1)

barplot(all_aucs[order(all_aucs, decreasing = T)], col = as.factor(all_aucs_orig[order(all_aucs, decreasing = T)]),
        ylim= c(0.6, 0.95))
legend("topright", legend = c("Recip_AUCs", "D-R_AUCs", "D AUCs"),
      col = c("green", "red", "black"), lty = 1)
```

Percentage of every data origin in the top 100 metabolites once sorted per AUC:
```{r}
ordered_aucs_orig <- all_aucs_orig[order(all_aucs, decreasing = T)]
table(ordered_aucs_orig[1:100])
```

Top 100 genes sorted on AUC:
```{r}
colnames(dr_AUCs) = colnames(donor_AUCs) = colnames(recip_AUCs) <- c("metabolites_of_interest", "auc")
dr_AUCs$metabolites_of_interest <- paste0("DR_", dr_AUCs$metabolites_of_interest)
donor_AUCs$metabolites_of_interest <- paste0("D_", donor_AUCs$metabolites_of_interest)
recip_AUCs$metabolites_of_interest <- paste0("R_", recip_AUCs$metabolites_of_interest)

global_aucs <- rbind(recip_AUCs, dr_AUCs, donor_AUCs)
ordered_global_aucs <- global_aucs[order(global_aucs$auc, decreasing = T),]
ordered_global_aucs[1:100,]
```



Venndiagram plot:
```{r, eval = FALSE}
venn.plot <- draw.triple.venn(length(recip_AUCs$auc), 
                              length(donor_AUCs$auc),
                              length(dr_AUCs$auc),
                              length(which(recip_AUCs$metabolites_of_interest_recip %in% donor_AUCs$metabolites_of_interest_donors)),
                              length(which(donor_AUCs$metabolites_of_interest_donors %in% dr_AUCs$metabolites_of_interest_dr)),
                              length(which(recip_AUCs$metabolites_of_interest_recip %in% dr_AUCs$metabolites_of_interest_dr)),
                              length(Reduce(intersect, list(recip_AUCs$metabolites_of_interest_recip,
                                                            donor_AUCs$metabolites_of_interest_donors,
                                                            dr_AUCs$metabolites_of_interest_dr))),
                              c("R", "D", "D-R"), col = c("green", "black", "red"))
venn <- grid.draw(venn.plot)
plot(venn)
```

Top 100 genes sorted on AUC:
```{r}
colnames(dr_AUCs) = colnames(donor_AUCs) = colnames(recip_AUCs) <- c("top_100_goi", "auc")
dr_AUCs <- dr_AUCs %>% 
  mutate(new_names = paste0("DR_", dr_AUCs[,1]))
donor_AUCs <- donor_AUCs %>% 
  mutate( new_names = paste0("D_", donor_AUCs[,1]))
recip_AUCs <- recip_AUCs %>% 
  mutate(new_names = paste0("R_", recip_AUCs[,1]))

global_aucs <- rbind(recip_AUCs, dr_AUCs, donor_AUCs)
ordered_global_aucs <- global_aucs[order(global_aucs$auc, decreasing = T),]
ordered_global_aucs[1:100,]
```

Venndiagram plot:
```{r}
grid.newpage()
venn.plot <- draw.triple.venn(length(recip_AUCs$auc), 
                              length(donor_AUCs$auc),
                              length(dr_AUCs$auc),
                              length(which(recip_AUCs$top_100_goi %in% donor_AUCs$top_100_goi)),
                              length(which(donor_AUCs$top_100_goi %in% dr_AUCs$top_100_goi)),
                              length(which(recip_AUCs$top_100_goi %in% dr_AUCs$top_100_goi)),
                              length(Reduce(intersect, list(recip_AUCs$top_100_goi,
                                                            donor_AUCs$top_100_goi,
                                                            dr_AUCs$top_100_goi))),
                              c("R", "D", "D-R"), 
                              fill = c("green", "black", "red"),
                              alpha = rep(0.25, 3),
                              lty = "blank",
                              ind = TRUE)
```






Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
