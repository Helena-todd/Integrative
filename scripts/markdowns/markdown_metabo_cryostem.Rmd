---
title: "Metabo_Cryostem_cohort"
author: "helena"
date: "29/03/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r imports, echo=FALSE, results='hide', warning = FALSE}
suppressPackageStartupMessages({
  library(dplyr)
  library(openxlsx)
  library(metabolomics)
  library(BioGVHD)
  library(tidyverse)
  library(data.table)
  library(dendextend)
  library(ggplot2)
  library(mlbench)
  library(caret)
  library(nnet)
  library(pROC)
  library(igraph)
  library(VennDiagram)
})
options("scipen"=100)
```


## Preprocessing of the data

I first read in the data:
Issue : dupplicated rows??
  + only 126 rows instead of the 140 in the metadata file

```{r load_data_1}
load("~/Documents/VIB/Projects/Integrative_Paris/National_cohort/samp_rd_national.RData")
samp_rd$METABONAME <- gsub(pattern = " ", replacement = "_", x = samp_rd$METABONAME)
samp_rd$GROUP <- as.factor(tolower(samp_rd$GROUP))

info <- extract_info_metabo(metadata_file = samp_rd,
                            metabo_file = "~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/Metabo NATIONAL cohort CRYOSTEM_filtered.xlsx")
rd_meta <- info$subset_meta
meta_metabo <- info$meta_metabo
data_metabolites <- info$data_metabolites
```

I then filter out the metabolies that are xenobiotics drugs, as well as the metabolites which are not common to both the St Louis and the Cryostem cohort:

```{r}
data_metabolites <- data_metabolites[,-which(which(meta_metabo[2,]=="Xenobiotics") %in% 
                                          grep("Drug", meta_metabo[3,]))] # rm drug xenobiotics
data_metabo_local <- read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/Local_cohort/Metabo/Metabolomic local cohort Saint-Louis_filtered.xlsx", rows = c(1:82), colNames = F, rowNames = T)
local_metabolites <- data_metabo_local[3,]
other_cohort_metabolites <- local_metabolites
```

# Analysis on the recipients only

I use my home made function to pre-process the metabolites as I did for the local cohort: 
- I filter out the metabolies that are not common to both the St Louis and the Cryostem cohort
- I filter out the metabolites for which we have more than 50% of missing values in all our sub-groups (non-tolerant, tolerant 1 or tolerant 2 recipients)
- I replace the missing values by 1/2 of the smallest value measured for each metabolite plus some noise
- I filter out the metabolites that do not vary enough across patients
- I finally log-transform, normalise and save the data

```{r generate_david_figure_1, echo = FALSE, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, message = FALSE, include=FALSE}
names_2rm <- read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/patients_to_rm_cryostem.xlsx",
                       colNames = FALSE)
names_2rm <- gsub(" ", "_", names_2rm$X1)

names_patients <- rownames(data_metabolites)[-grep("D0", rownames(data_metabolites))]
names_patients <- names_patients[-which(names_patients %in% names_2rm)]

data_metabolites <- data_metabolites[names_patients,]
rd_meta <- rd_meta[names_patients,]

res_preprocessing <- metabo_preprocess(patient_type = "recipients", data_metabolites, meta_metabo,
                                       other_cohort_metabolites, rd_meta, names_patients,
                                       pdf_name = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/recip/preprocess_removed_metabolites.pdf",
                                       pdf_variance_name = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/recip/preprocess_variance_cutoff.pdf",
                                       save_results = T, save_res_repository = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/recip_minus3patients/")
```

```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/recip_minus3patients/norm_data.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/recip_minus3patients/meta_metabo.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/recip_minus3patients/big_mat.RData")
norm_data$Group <- as.factor(norm_data$Group)
```

PCA on the recipients to see if there isn't too much batch effect:
```{r}
pca <- prcomp(norm_data[,-1])
plot(pca$x, col = big_mat$Group)
plot(pca$x, col = as.factor(big_mat$HOSPITAL))
```


Random forest on the recipients only : 
```{r, echo = FALSE}
colnames(norm_data) <- make.names(colnames(norm_data))

rf_recip <- randomForest::randomForest(Group~., norm_data, mtry = 40)
rf_recip
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
colnames(norm_data)[1] <- "group"
norm_data$group <- tolower(norm_data$group)

set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data, mtry = 30, ntree = 10000)
rf1
```



Volcano plots between tolerant and non tolerant patients: 

```{r}
mat2use <- norm_data
gr <- as.character(norm_data$group)
gr[which(gr!= "non_tolerant")] <- "tolerant"
mat2use$group <- as.factor(gr)

res <- TwoGroup(mat2use)
VolcanoPlot(res$output[,4], res$output[,2], cexlab = 0.6)
MetBoxPlots(mat2use, "tartarate",cols = c("blue","red"),main = "tartarate")
MetBoxPlots(mat2use, "diacylglycerol..12.0.18.1..14.0.16.1..16.0.14.1...2..",cols = c("blue","red"),main = "diacylglycerol..12.0.18.1..14.0.16.1..16.0.14.1...2..")
MetBoxPlots(mat2use, "taurocholenate.sulfate",cols = c("blue","red"),main = "taurocholenate.sulfate")
MetBoxPlots(mat2use, "propyl.4.hydroxybenzoate.sulfate",cols = c("blue","red"),main = "propyl.4.hydroxybenzoate.sulfate")
```

Trying to classify only primary and seconday tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data, mtry = 30, ntree = 10000)
rf_tol
```

Volcano plots between primary and secondary tolerant patients: 

```{r}
mat2use <- norm_data[which(norm_data$group!="non_tolerant"),]

res <- TwoGroup(mat2use)
VolcanoPlot(res$output[,4], res$output[,2], cexlab = 0.6)
MetBoxPlots(mat2use, "thymol.sulfate",cols = c("blue","green"),main = "thymol.sulfate")
```

## Feature selection

I apply feature selection to extract the metabolites which are correlated to the patients' outcome:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE}

## fit a multinomial log linear model to every variable separately,
## and extract the residual deviance (what has not been explained by the variable):
model_stats <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)
  
  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]
  
  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>% 
  group_by(group) %>% 
  summarize_if(is.numeric, median) %>% 
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```


Barplot of the residuals to see which metabolites explain the most of the inter group variance :
```{r}
residual_values <- purrr::map(model_stats, 1)
barplot(unlist(model_stats))
abline(h= 55, col = "red")
```


Names of the metabloites which are correlated to the patients' outcome:
```{r}
metabolires_of_interest_residuals <- colnames(norm_data)[which(residual_values <= 55)+1]
metabolires_of_interest_residuals
```

Identifying the metabolites which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats, 2)
barplot(unlist(global_aucs))
abline(h= 0.647, col = "red")
```

```{r}
metabolites_of_interest <- colnames(norm_data)[which(global_aucs >= 0.647)+1]
metabolites_of_interest
```

I save the AUCs corresponding to these 100 top metabolites:
```{r}
recip_AUCs <- as.data.frame(metabolites_of_interest) %>% 
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.647)]))
  
save(recip_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/recip_AUCs.RData")
```

Metabolites that help the most to predict between non-tolerant and primary tolerant recipients :

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.8, col = "red")
```

The metabolites help much less to predict the class, so I'll lower the thresholds for the Cryostem cohort:

```{r}
non_prim_aucs <- purrr::map(model_stats, 3)
barplot(unlist(non_prim_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_prim_metabolites <- colnames(norm_data)[which(non_prim_aucs >= 0.75)+1]
non_prim_metabolites
```

Which of these metabolites can be grouped together?
The metabolites are colored in yellow in the graph because they correspond to the metabolites which most differ between non tolerant patients (that I always represent in red) and primary tolerant patients (that I always represent in green).
```{r}
correlations_non_prim <- norm_data[,non_prim_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = "yellow")

```

Color the metabolites that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:

```{r}
nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
```

Metabolites that help the most to predict between non-tolerant and secondary tolerant recipients :

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.8, col = "red")
```

The metabolites help much less to predict the class, so I'll lower the thresholds for the Cryostem cohort:

```{r}
non_sec_aucs <- purrr::map(model_stats, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_sec_metabolites <- colnames(norm_data)[which(non_sec_aucs >= 0.75)+1]
non_sec_metabolites
```

How are these metabolites correlated?
These metabolites are colored in purple because they differ the most between non-tolerant (red) and secondary tolerant (blue) patients.
```{r}
correlations_non_sec <- norm_data[,non_sec_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = "purple")

```

Color the metabolites that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
```

Metabolites that help the most to predict between primary and secondary tolerant recipients :

```{r}
prim_sec_aucs <- purrr::map(model_stats, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.7, col = "red")
```

```{r}
prim_sec_metabolites <- colnames(norm_data)[which(prim_sec_aucs >= 0.7)+1]
prim_sec_metabolites
```

How are these metabolites correlated?
These metabolites are colored in turquoise because they differ the most between primary-tolerant (green) and secondary tolerant (blue) patients.
```{r}
correlations_prim_sec <- norm_data[,prim_sec_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.7),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = "turquoise")

```

Color the metabolites that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the secondary tolerant patients in blue:

```{r}
nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("blue", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["secondary_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
```

More global approach: over all metabolites of interest, no matter if they separate non-tol from primary, non-tol from secondary... 
Group the metabolites that are associated with the outcome (= the "metabolites of interest") together, by finding the ones that are most correlated between them:

```{r}
#cor(norm_data[,metabolites_of_interest[1]], norm_data[,metabolites_of_interest[2]])
correlations <- norm_data[,metabolites_of_interest] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)
```


```{r}
correlated_features <- correlations[which(correlations$value > 0.8),]
```

```{r}
library(igraph)
gr <- graph_from_data_frame(correlated_features, directed = FALSE)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20)
```

I color the metabolites based on the role they play in distinguishing non tolerant from primary, ...
```{r}
metabolite_colors <- rep("lightgrey", length(metabolites_of_interest))
metabolite_colors[which(metabolites_of_interest %in% non_prim_metabolites)] <- "yellow"
metabolite_colors[which(metabolites_of_interest %in% non_sec_metabolites)] <- "purple"
metabolite_colors[which(metabolites_of_interest %in% prim_sec_metabolites)] <- "turquoise"

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20, 
     vertex.color = metabolite_colors)
```

Color the metabolites that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors only:
```{r}
set.seed(1)
rf_dr <- ranger::ranger(group~., norm_data[,c("group", metabolites_of_interest)], mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_dr$confusion.matrix
paste0("prediction error: ", rf_dr$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", metabolites_of_interest)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", metabolites_of_interest)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors only :

```{r load_data_donor}
load("~/Documents/VIB/Projects/Integrative_Paris/National_cohort/samp_rd_national.RData")
samp_rd$METABONAME <- gsub(pattern = " ", replacement = "_", x = samp_rd$METABONAME)
samp_rd$GROUP <- as.factor(tolower(samp_rd$GROUP))

info <- extract_info_metabo(metadata_file = samp_rd,
                            metabo_file = "~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/Metabo NATIONAL cohort CRYOSTEM_filtered.xlsx")
rd_meta <- info$subset_meta
meta_metabo <- info$meta_metabo
data_metabolites <- info$data_metabolites
```

I then filter out the metabolies that are xenobiotics drugs, as well as the metabolites which are not common to both the St Louis and the Cryostem cohort:

```{r}
data_metabolites <- data_metabolites[,-which(which(meta_metabo[2,]=="Xenobiotics") %in% 
                                          grep("Drug", meta_metabo[3,]))] # rm drug xenobiotics
data_metabo_local <- read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/Local_cohort/Metabo/Metabolomic local cohort Saint-Louis_filtered.xlsx", rows = c(1:82), colNames = F, rowNames = T)
local_metabolites <- data_metabo_local[3,]
other_cohort_metabolites <- local_metabolites
```

I use my home made function to pre-process the metabolites as I did for the local cohort: 
- I filter out the metabolies that are not common to both the St Louis and the Cryostem cohort
- I filter out the metabolites for which we have more than 50% of missing values in all our sub-groups (non-tolerant, tolerant 1 or tolerant 2 recipients)
- I replace the missing values by 1/2 of the smallest value measured for each metabolite plus some noise
- I filter out the metabolites that do not vary enough across patients
- I finally log-transform, normalise and save the data


```{r generate_david_figure_donor, echo = FALSE, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, message = FALSE, include=FALSE}
names_2rm <- read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/patients_to_rm_cryostem.xlsx",
                       colNames = FALSE)
names_2rm <- gsub(" ", "_", names_2rm$X1)

names_patients <- rownames(data_metabolites)[grep("D0", rownames(data_metabolites))]
names_patients <- names_patients[-which(names_patients %in% names_2rm)]

data_metabolites <- data_metabolites[names_patients,]
rd_meta <- rd_meta[names_patients,]

res_preprocessing <- metabo_preprocess(patient_type = "donors", data_metabolites, meta_metabo,
                                       other_cohort_metabolites, rd_meta, names_patients,
                                       pdf_name = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/donors/preprocess_removed_metabolites.pdf",
                                       pdf_variance_name = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/donors/preprocess_variance_cutoff.pdf",
                                       save_results = T, save_res_repository = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/donors_minus3patients/")
```

```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/donors_minus3patients/norm_data.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/donors_minus3patients/meta_metabo.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/donors_minus3patients/big_mat.RData")
norm_data$Group <- as.factor(norm_data$Group)
```

Random forest on the donors only : 
```{r, echo = FALSE}
colnames(norm_data) <- make.names(colnames(norm_data))

set.seed(1)
rf_donor <- randomForest::randomForest(Group~., norm_data, mtry = 40)
rf_donor
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
colnames(norm_data)[1] <- "group"
norm_data$group <- tolower(norm_data$group)

set.seed(1)
rf1d <- rf_tol_non_tol(df_orig = norm_data, mtry = 30, ntree = 10000)
rf1d
```

Trying to classify only primary and seconday tolerant donors:
```{r, echo = FALSE}
set.seed(1)
rfd_tol <- rf_tol1_tol2(df_orig = norm_data, mtry = 30, ntree = 10000)
rfd_tol
```

## Feature selection

I apply feature selection to extract the metabolites which are correlated to the patients' outcome:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE}

## fit a multinomial log linear model to every variable separately,
## and extract the residual deviance (what has not been explained by the variable):
model_stats_donors <- lapply(colnames(norm_data)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = norm_data)
  
  global_auc <- multiclass.roc(norm_data$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(norm_data$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]
  
  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```


Compute the median per group for every metabolite, to use it later in the graphs:
```{r}
gr_medians <- norm_data %>% 
  group_by(group) %>% 
  summarize_if(is.numeric, median) %>% 
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```

Identifying the top 100 metabolites which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats_donors, 2)
barplot(unlist(global_aucs))
abline(h= 0.593, col = "red")
```

```{r}
metabolites_of_interest_donors <- colnames(norm_data)[which(global_aucs >= 0.598)+1]
metabolites_of_interest_donors
```


I save the table of the top 100 metabolites in the donors:
```{r}
samp_donor <- samp_rd[which(samp_rd$METABONAME %in% rownames(norm_data)),]
rownames(samp_donor) <- samp_donor$METABONAME
samp_donor <- samp_donor[rownames(norm_data),]

norm_data_donors_selec <- norm_data[,metabolites_of_interest_donors]
colnames(norm_data_donors_selec) <- paste0("D_", colnames(norm_data_donors_selec))
norm_data_donors_selec <- norm_data_donors_selec %>% 
  mutate("couple_nb" = samp_donor$COUPLENUMBER,
         "group" = samp_donor$GROUP,
         "Id.Cryostem.R" = samp_donor$Id.Cryostem.R)
save(norm_data_donors_selec, 
     file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/norm_data_donors_selec.RData")
```


I save the AUCs corresponding to these 100 top metabolites:
```{r}
donor_AUCs <- as.data.frame(metabolites_of_interest_donors) %>% 
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.598)]))
  
save(donor_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/donor_AUCs.RData")
```


Random forest on the features selected from the donors only:
```{r, echo = FALSE}
norm_data_donor_selec <- as.data.frame(norm_data[,c("group",metabolites_of_interest_donors)])
norm_data_donor_selec$group <- as.factor(norm_data_donor_selec$group)

rf_donor_selec <- randomForest::randomForest(group~., norm_data_donor_selec, mtry = 40)
rf_donor_selec
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1d_selec <- rf_tol_non_tol(df_orig = norm_data_donor_selec, mtry = 30, ntree = 10000)
rf1d_selec
```

```{r}
non_prim_aucs <- purrr::map(model_stats_donors, 3)
non_prim_metabolites <- colnames(norm_data)[which(non_prim_aucs >= 0.7)+1]
non_prim_metabolites
```

Which of these metabolites can be grouped together?
Color the metabolites that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:

```{r}
donor_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/donors/"

correlations_non_prim <- norm_data[,non_prim_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}
pdf(paste0(donor_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
```

Metabolites that help the most to predict between non-tolerant and secondary tolerant recipients :

```{r}
non_sec_aucs <- purrr::map(model_stats_donors, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.7, col = "red")
```

```{r}
non_sec_metabolites <- colnames(norm_data)[which(non_sec_aucs >= 0.7)+1]
non_sec_metabolites
```

How are these metabolites correlated?
Color the metabolites that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:
```{r}
correlations_non_sec <- norm_data[,non_sec_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(donor_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Metabolites that help the most to predict between primary and secondary tolerant donors :

```{r}
prim_sec_aucs <- purrr::map(model_stats_donors, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.7, col = "red")
```

```{r}
prim_sec_metabolites <- colnames(norm_data)[which(prim_sec_aucs >= 0.7)+1]
prim_sec_metabolites
```

I can't look at the correlations between thes emetabolites because they are tto few, and they are not correlated.

More global approach: over all metabolites of interest, no matter if they separate non-tol from primary, non-tol from secondary... 
Group the metabolites that are associated with the outcome (= the "metabolites of interest") together, by finding the ones that are most correlated between them:

```{r}
#cor(norm_data[,metabolites_of_interest[1]], norm_data[,metabolites_of_interest[2]])
correlations <- norm_data[,metabolites_of_interest_donors] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)
```


```{r}
correlated_features <- correlations[which(correlations$value > 0.8),]
```

Color the metabolites that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
gr <- graph_from_data_frame(correlated_features, directed = FALSE)
nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(donor_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors only:
```{r}
set.seed(1)
rf_d <- ranger::ranger(group~., norm_data[,c("group", metabolites_of_interest_donors)], mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_d$confusion.matrix
paste0("prediction error: ", rf_d$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = norm_data[,c("group", metabolites_of_interest_donors)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = norm_data[,c("group", metabolites_of_interest_donors)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors - recipients :

In order to investigate into the differences between the recipients' metabolite profile compared to the original profile of their donor, I'm running the same analysis on the donors-recipients (matched per couple of course)

```{r load_data_dr}
load("~/Documents/VIB/Projects/Integrative_Paris/National_cohort/samp_rd_national.RData")
samp_rd$METABONAME <- gsub(pattern = " ", replacement = "_", x = samp_rd$METABONAME)
samp_rd$GROUP <- as.factor(tolower(samp_rd$GROUP))

info <- extract_info_metabo(metadata_file = samp_rd,
                            metabo_file = "~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/Metabo NATIONAL cohort CRYOSTEM_filtered.xlsx")
data_metabolites <- info$data_metabolites

samp_rd <- samp_rd[which(samp_rd$METABONAME %in% rownames(data_metabolites)),]
info <- extract_info_metabo(metadata_file = samp_rd,
                            metabo_file = "~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/Metabo NATIONAL cohort CRYOSTEM_filtered.xlsx")


rd_meta <- info$subset_meta
meta_metabo <- info$meta_metabo
data_metabolites <- info$data_metabolites

save(rd_meta, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/r&d/rd_meta.RData")
```

I then filter out the metabolies that are xenobiotics drugs, as well as the metabolites which are not common to both the St Louis and the Cryostem cohort:

```{r}
data_metabolites <- data_metabolites[,-which(which(meta_metabo[2,]=="Xenobiotics") %in% 
                                          grep("Drug", meta_metabo[3,]))] # rm drug xenobiotics
data_metabo_local <- read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/Local_cohort/Metabo/Metabolomic local cohort Saint-Louis_filtered.xlsx", rows = c(1:82), colNames = F, rowNames = T)
local_metabolites <- data_metabo_local[3,]
other_cohort_metabolites <- local_metabolites
```

I use my home made function to pre-process the metabolites as I did for the local cohort: 
- I filter out the metabolies that are not common to both the St Louis and the Cryostem cohort
- I filter out the metabolites for which we have more than 50% of missing values in all our sub-groups (non-tolerant, tolerant 1 or tolerant 2 recipients)
- I replace the missing values by 1/2 of the smallest value measured for each metabolite plus some noise
- I filter out the metabolites that do not vary enough across patients
- I finally log-transform, normalise and save the data

```{r fonction_perso, echo = FALSE, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, message = FALSE, include=FALSE}
names_2rm <- read.xlsx("~/Documents/VIB/Projects/Integrative_Paris/National_cohort/Metabo/patients_to_rm_cryostem.xlsx",
                       colNames = FALSE)
names_2rm <- gsub(" ", "_", names_2rm$X1)

names_patients <- rownames(data_metabolites)
names_patients <- names_patients[-which(names_patients %in% names_2rm)]

data_metabolites <- data_metabolites[names_patients,]
rd_meta <- rd_meta[names_patients,]

res_preprocessing <- metabo_preprocess(patient_type = "donors and recipients", data_metabolites, meta_metabo,
                                       other_cohort_metabolites, rd_meta, names_patients,
                                       pdf_name = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/r&d/preprocess_removed_metabolites.pdf",
                                       pdf_variance_name = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/r&d/preprocess_variance_cutoff.pdf",
                                       save_results = T, save_res_repository = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/r&d_minus3patients/")

save(rd_meta, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/r&d_minus3patients/rd_meta.RData")
```


```{r, results = 'hide'}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/r&d_minus3patients/big_mat.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/r&d_minus3patients/rd_meta.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/r&d_minus3patients/norm_data.RData")
norm_data$Group <- as.factor(norm_data$Group)

vars2rm <- colnames(rd_meta)[-c(4, 10)]
big_mat2 <- big_mat %>%
  group_by(COUPLENUMBER) %>%
  dplyr::select(-vars2rm)

subst <- big_mat2 %>%
  summarise_if(is.numeric, ~.[1]-.[2])

rd_meta_subst <- rd_meta[which(rd_meta$COUPLENUMBER %in% subst$COUPLENUMBER),] %>% 
  arrange(COUPLENUMBER) %>% 
  dplyr::select(c("GROUP", "COUPLENUMBER")) %>% 
  unique()

subst <- subst %>% 
  mutate("couple" = paste0("couple_",COUPLENUMBER),
         "group" = rd_meta_subst$GROUP) %>% 
  column_to_rownames("couple") %>% 
  dplyr::select (-"COUPLENUMBER") 

subst <- subst[c(ncol(subst), 1:(ncol(subst)-1))]

colnames(subst) <- make.names(colnames(subst))
colnames(subst)[-1] <- paste0("subst_", colnames(subst))[-1]
```

Random forest on the donors - recipients:
```{r}
subst$group <- as.factor(subst$group)
colnames(subst) <- make.names(colnames(subst))

set.seed(1)
rf_subst <- randomForest::randomForest(group~., subst, mtry = 40)
rf_subst
```

Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
subst$group <- tolower(subst$group)

set.seed(1)
rf1_subst <- rf_tol_non_tol(df_orig = subst, mtry = 30, ntree = 10000)
rf1_subst
```

Trying to classify only primary and seconday tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_subst_tol <- rf_tol1_tol2(df_orig = subst, mtry = 30, ntree = 10000)
rf_subst_tol
```

## Feature selection

I apply feature selection to extract the metabolites which are correlated to the patients' outcome:
```{r, cache=FALSE, results='hide', warning=FALSE, comment=FALSE, warning=FALSE, message = FALSE, include=FALSE}

## fit a multinomial log linear model to every variable separately,
## and extract the residual deviance (what has not been explained by the variable):
model_stats_dr <- lapply(colnames(subst)[-1], function(variable){
  fit_var <- multinom(group ~ eval(parse(text=variable)), data = subst)
  
  global_auc <- multiclass.roc(subst$group,fitted(fit_var))$auc[[1]]
  auc_non_primary <- multiclass.roc(subst$group,fitted(fit_var),levels=c("non_tolerant","primary_tolerant"))$auc[[1]]
  auc_non_secondary <- multiclass.roc(subst$group,fitted(fit_var),levels=c("non_tolerant","secondary_tolerant"))$auc[[1]]
  auc_primary_secondary <- multiclass.roc(subst$group,fitted(fit_var),levels=c("primary_tolerant","secondary_tolerant"))$auc[[1]]
  
  return(lst(residual_var = fit_var$deviance, global_auc = global_auc, auc_non_primary = auc_non_primary,
             auc_non_secondary = auc_non_secondary, auc_primary_secondary = auc_primary_secondary))
})
```

Compute the median per group for every gene, to use it later in the graphs:
```{r}
gr_medians <- subst %>% 
  group_by(group) %>% 
  summarize_if(is.numeric, median) %>% 
  as.data.frame()
rownames(gr_medians) <- gr_medians$group
```

Identifying the top 100 metabolites which best match with the patients outcome, 2 by 2 (non-tolerant versus tolerant 1,
non-tolerant versus tolerant 2 and tolerant 1 versus tolerant 2):

```{r}
global_aucs <- purrr::map(model_stats_dr, 2)
barplot(unlist(global_aucs))
abline(h= 0.7, col = "red")
```

```{r}
metabolites_of_interest_dr <- colnames(subst)[which(global_aucs >= 0.705)+1]
metabolites_of_interest_dr
```

Generate a matrix with the selected metabolites only:
```{r}
samp_dr <- samp_rd[which(samp_rd$COUPLENUMBER %in% gsub("couple_", "", rownames(subst))),] %>% 
  arrange(COUPLENUMBER) %>% 
  dplyr::select(c("GROUP", "COUPLENUMBER")) %>% 
  unique()

subst_dr_selec <- subst[,metabolites_of_interest_dr]
colnames(subst_dr_selec) <- paste0("DR_", colnames(subst_dr_selec))
subst_dr_selec <- subst_dr_selec %>% 
  mutate("couple_nb" = samp_dr$COUPLENUMBER,
         "group" = samp_dr$GROUP,
         "Id.Cryostem.R" = samp_dr$Id.Cryostem.R)
save(subst_dr_selec, 
     file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/subst_dr_selec.RData")
```

I save the AUCs corresponding to these 100 top metabolites:
```{r}
dr_AUCs <- as.data.frame(metabolites_of_interest_dr) %>% 
  mutate(auc = unlist(global_aucs[which(global_aucs >= 0.705)]))
  
save(dr_AUCs, file = "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/dr_AUCs.RData")
```

```{r}
non_prim_aucs <- purrr::map(model_stats_dr, 3)
non_prim_metabolites <- colnames(subst)[which(non_prim_aucs >= 0.75)+1]
non_prim_metabolites
```

Which of these metabolites can be grouped together?
Color the metabolites that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the non tolerant patients in red:

```{r}
dr_path <- "~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/plots/metabo_national/r&d/"

correlations_non_prim <- subst[,non_prim_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_prim_features <- correlations_non_prim[which(correlations_non_prim$value > 0.8),]

gr_NP <- graph_from_data_frame(cor_non_prim_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_NP)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "NP.pdf"), width = 12, height = 8)
plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NP, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NP)$value - .7) * 20,
     vertex.color = color_nodes)
```

Metabolites that help the most to predict between non-tolerant and secondary tolerant recipients :

```{r}
non_sec_aucs <- purrr::map(model_stats_donors, 4)
barplot(unlist(non_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
non_sec_metabolites <- colnames(subst)[which(non_sec_aucs >= 0.75)+1]
non_sec_metabolites
```

How are these metabolites correlated?
Color the metabolites that are more expressed in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

Not enough metabolites to plot them, and they are not correlated.
```{r, eval = FALSE, echo = FALSE}
correlations_non_sec <- subst[,non_sec_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_non_sec_features <- correlations_non_sec[which(correlations_non_sec$value > 0.8),]

gr_NS <- graph_from_data_frame(cor_non_sec_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_NS)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] > medians["non_tolerant", gene]){
    color_nodes[gene] <- "blue"
  }
}

pdf(paste0(dr_path, "NS.pdf"), width = 12, height = 8)
plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_NS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_NS)$value - .7) * 20,
     vertex.color = color_nodes)

```

Metabolites that help the most to predict between primary and secondary tolerant donors :

```{r}
prim_sec_aucs <- purrr::map(model_stats_donors, 5)
barplot(unlist(prim_sec_aucs))
abline(h= 0.75, col = "red")
```

```{r}
prim_sec_metabolites <- colnames(subst)[which(prim_sec_aucs >= 0.75)+1]
prim_sec_metabolites
```

How are these metabolites correlated?
Color the metabolites that are more expressed in the primary tolerant patients in green, and the ones that are more expressed in the secondary tolerant patients in blue:

If I use the same threshold as for the non-primary comparison, no metabolites pop out
```{r, eval = FALSE, echo = FALSE}
correlations_prim_sec <- subst[,prim_sec_metabolites] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)

cor_prim_sec_features <- correlations_prim_sec[which(correlations_prim_sec$value > 0.7),]

gr_PS <- graph_from_data_frame(cor_prim_sec_features, directed = FALSE)

nodes <- get.vertex.attribute(gr_PS)
color_nodes <- rep("blue", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["primary_tolerant", gene] > medians["secondary_tolerant", gene]){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "PS.pdf"), width = 12, height = 8)
plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr_PS, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr_PS)$value - .7) * 20,
     vertex.color = color_nodes)

```

More global approach: over all metabolites of interest, no matter if they separate non-tol from primary, non-tol from secondary... 
Group the metabolites that are associated with the outcome (= the "metabolites of interest") together, by finding the ones that are most correlated between them:

```{r}
#cor(norm_data[,metabolites_of_interest[1]], norm_data[,metabolites_of_interest[2]])
correlations <- subst[,metabolites_of_interest_dr] %>% 
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>% 
  dplyr::filter(var1 < var2)
```


```{r}
correlated_features <- correlations[which(correlations$value > 0.8),]
```

Color the metabolites that are more expressed in the primary tolerant patients in green, in the secondary tolerant patients in blue, and the ones that are more expressed in the non tolerant patients in red:

```{r}
gr <- graph_from_data_frame(correlated_features, directed = FALSE)
nodes <- get.vertex.attribute(gr)
color_nodes <- rep("red", length(nodes$name))
medians <- gr_medians[,nodes$name]
for (gene in seq_along(colnames(medians))){
  if (medians["secondary_tolerant", gene] == max(medians[, gene])){
    color_nodes[gene] <- "blue"
  } else if(medians["primary_tolerant", gene]  == max(medians[, gene])){
    color_nodes[gene] <- "green"
  }
}

pdf(paste0(dr_path, "all.pdf"), width = 12, height = 8)
plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
dev.off()

plot(gr, vertex.size = 7, vertex.label.cex = .5, edge.width = (E(gr)$value - .7) * 20,
     vertex.color = color_nodes)
```

Random forest on the selected genes of the donors only:
```{r}
set.seed(1)
rf_dr <- ranger::ranger(group~., subst[,c("group", metabolites_of_interest_dr)], mtry = 40, num.trees = 1000,
                           importance = "impurity")
rf_dr$confusion.matrix
paste0("prediction error: ", rf_dr$prediction.error*100)
```
Trying to classify between non tolerant and tolerant patients:

```{r, echo=FALSE}
set.seed(1)
rf1 <- rf_tol_non_tol(df_orig = subst[,c("group", metabolites_of_interest_dr)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf1$confusion.matrix
paste0("prediction error: ", rf1$prediction.error*100)
```

Trying to classify only primary and secondary tolerant recipients:
```{r, echo = FALSE}
set.seed(1)
rf_tol <- rf_tol1_tol2(df_orig = subst[,c("group", metabolites_of_interest_dr)], mtry = 30, ntree = 10000, package_2use = "ranger")
rf_tol$confusion.matrix
paste0("prediction error: ", round(rf_tol$prediction.error*100, digits = 3))
```

# Analysis on the donors, recipients, and D-R

Which of the three hold the most information to perform classification?

Plot the AUCs of the 100 top metabolites from every data source (D, R, D-R)
```{r}
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/donor_AUCs.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/recip_AUCs.RData")
load("~/Documents/VIB/Projects/Integrative_Paris/Integrative/outputs/data/metabo_national/compar/dr_AUCs.RData")

all_aucs <- c(recip_AUCs$auc, dr_AUCs$auc, donor_AUCs$auc)
all_aucs_orig <- c(rep("R", nrow(donor_AUCs)),
                   rep("DR", nrow(recip_AUCs)),
                   rep("D", nrow(dr_AUCs)))
barplot(all_aucs, col = as.factor(all_aucs_orig), ylim = c(0.6, 0.95))
legend("topright", legend = c("Recip_AUCs", "D-R_AUCs", "Donor AUCs"),
      col = c("green", "red", "black"), lty = 1)

barplot(all_aucs[order(all_aucs, decreasing = T)], col = as.factor(all_aucs_orig[order(all_aucs, decreasing = T)]),
        ylim= c(0.6, 0.95))
legend("topright", legend = c("Recip_AUCs", "D-R_AUCs", "D AUCs"),
      col = c("green", "red", "black"), lty = 1)
```

Percentage of every data origin in the top 100 metabolites once sorted per AUC:
```{r}
ordered_aucs_orig <- all_aucs_orig[order(all_aucs, decreasing = T)]
table(ordered_aucs_orig[1:100])
```

Top 100 metabolites sorted on AUC:
```{r}
colnames(dr_AUCs) = colnames(donor_AUCs) <- colnames(recip_AUCs)
dr_AUCs$metabolites_of_interest <- paste0("DR_", dr_AUCs$metabolites_of_interest)
donor_AUCs$metabolites_of_interest <- paste0("D_", donor_AUCs$metabolites_of_interest)
recip_AUCs$metabolites_of_interest <- paste0("R_", recip_AUCs$metabolites_of_interest)

global_aucs <- rbind(recip_AUCs, dr_AUCs, donor_AUCs)
ordered_global_aucs <- global_aucs[order(global_aucs$auc, decreasing = T),]
ordered_global_aucs[1:100,]
```


Venndiagram plot:
```{r, eval = FALSE}
grid.newpage()
venn.plot <- draw.triple.venn(length(recip_AUCs$auc), 
                              length(donor_AUCs$auc),
                              length(dr_AUCs$auc),
                              length(which(recip_AUCs$metabolites_of_interest_recip %in% donor_AUCs$metabolites_of_interest_donors)),
                              length(which(donor_AUCs$metabolites_of_interest_donors %in% dr_AUCs$metabolites_of_interest_dr)),
                              length(which(recip_AUCs$metabolites_of_interest_recip %in% dr_AUCs$metabolites_of_interest_dr)),
                              length(Reduce(intersect, list(recip_AUCs$metabolites_of_interest_recip,
                                                            donor_AUCs$metabolites_of_interest_donors,
                                                            dr_AUCs$metabolites_of_interest_dr))),
                              c("R", "D", "D-R"), 
                              fill = c("green", "black", "red"),
                              alpha = rep(0.25, 3),
                              lty = "blank",
                              ind = TRUE)

```

```{r}
print("Overlap between D and D-R : ")
donor_AUCs$metabolites_of_interest_donors[which(donor_AUCs$metabolites_of_interest_donors %in% dr_AUCs$metabolites_of_interest_dr)]
```






